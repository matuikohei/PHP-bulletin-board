13,14
掲示板アプリのコードの理解、コード修正
15
cssの作成
16
テストの実施
18
説明の作成
19,20

PHP BULLETIN BOARD /
・classes/
Board.php
Config.php
Database.php
DeleteConfirm.php
DeleteSuccess.php
SessionManager.php
UpdateEdit.php
User.php

・css/
styles.css

・text/
flowchart.text
NOTES.test

board.php
delete-confirm.php
delete-success.php
login.php
logout.php
register.php
update-edit.php
README.md




PHP BULLETIN BOARD/
├── classes/
│   ├── Board.php
│   ├── Config.php
│   ├── Config.php
│   ├── Config.php
│   ├── Config.php
│   └── Database.php
│
│
│
│
│
├── test/
│   ├── main.test.js
│   └── app.test.js
├── assets/
│   ├── styles.css
│   └── logo.png
├── README.md
└── package.json



<スーパーグローバル関数とは>
スーパーグローバル変数は、PHPのどこからでもアクセスできる特別な変数のこと。これらの変数は、特定の種類のデータを格納するために使われる。
スーパーグローバル変数は、PHPが自動的に提供する特別な配列（配列と連想配列がある）で、自分がコードを作成して配列を準備する必要はない。

主なスーパーグローバル変数
$_POST：フォームから送信されたデータを格納。
$_GET：URLパラメータから送信されたデータを格納。
$_SESSION：セッションデータを格納。
$_COOKIE：クッキーのデータを格納。
$_REQUEST：$_GET、$_POST、および$_COOKIEのデータを格納。
$_SERVER：サーバー環境に関する情報を格納。
$_FILES：ファイルのアップロードに関する情報を格納。
$_ENV：環境変数を格納。
$_GLOBALS：全てのグローバル変数を格納。






<$_POSTについて>
・$_POST：フォームのデータが入る箱
・‘post_btn’：ボタンの名前
・$_POST[‘post_btn’]：そのボタンが押されたという情報が格納される場所。






＜セッションとクッキーの違い iPhoneに例えると＞
セッション: サーバー側に保存され、ユーザーがウェブサイトを訪れている間だけ有効。ログイン状態など一時的なデータを管理するのに使われる。
クッキー: ブラウザに保存され、長期間にわたってデータを保持します。ユーザーの設定や訪問履歴などを保存するのに使われる。

iPhone
セッション: これは、アプリを開いている間にアプリ(WEBサイト)がサーバーに保存している情報。アプリを閉じたり、iPhoneを再起動したりすると、セッションは終了する。
クッキー: これは、iPhone自体に保存される設定情報。例えば、ブラウザのクッキーは、あなたがサイトを訪れるたびにその設定やログイン状態を記憶してくれる。iPhoneを再起動しても、クッキーは残っていて、次回サイトに訪れたときに再びログインした状態を維持する。






<掲示板サイトのセッションについて>
if (isset($_SESSION['cont_id'])) {
$cont_id = $_SESSION['cont_id'];
} else {
$_SESSION['cont_id'] =
chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) .
chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) .
chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) .
chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) .
chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) .
chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) .
chr(mt_rand(65, 90)) . chr(mt_rand(65, 90));
$cont_id = $_SESSION['cont_id'];
}
このコードでは、ユーザーごとの識別idをセッションに格納している







<isset関数を使う理由>
if (isset($_POST['post_btn'])) {
    // ボタンが押されたときの処理
}

ボタンが押されたを確認するため（エラーを起こさずに確認するため）
issetは変数が定義されているか確認するための関数。
フォームが送信されると、送信されたデータは $_POST 配列に格納される。もしボタンが押されていなければ、$_POST['post_btn'] は存在しない。isset を使うことで、ボタンが押されたかどうかを確認できる。
つまり、isset関数を使う理由は、ボタンが押されたかどうかを安全に確認するため。
もし isset を使わずに $_POST['post_btn'] にアクセスしようとすると、ボタンが押されていない場合にエラーが発生する可能性がある。具体的には下記のようなコードではエラーが起きる可能性がある。
if ($_POST['post_btn']) {
}

$_POST['post_btn'] が存在するかどうかを確認することで、ボタンが押された時にだけ処理を行うことでできる。これによりエラーを避けることできる。







<unset関数について　使う理由>
unset() を記述しない場合、古いデータや不要なデータがセッションに残り、次回フォームを表示したときに誤った情報が表示される可能性がある。
そのため最新の情報だけをセッションに保存し、フォームが正確に表示されるようにするためにunset関数を使用している






<if文がネストせずに連続する理由>
各 if 文の条件が独立しているから。それぞれの条件が順番にチェックされ、対応する処理が実行される。ネストを使う必要がないのは、各条件が他の条件に依存していないため。

・もし条件が独立しているとはどういうことか？
例

	1.	歯を磨く
	•	「もし起きたら、歯を磨く」
	2.	顔を洗う
	•	「もし起きたら、顔を洗う」
	3.	朝ごはんを食べる
	•	「もし起きたら、朝ごはんを食べる」

この3つの「もし〜したら」の条件は、それぞれ別々のことをしている。歯を磨くかどうかは、顔を洗うかどうかに関係ない。同じように、朝ごはんを食べるかどうかも、他の2つには関係ない。

だから、これらは独立していると言える。起きた時に、順番にこれらのことを確認して、それぞれをやるかどうかを決めます。


・もし条件が連続しているとはどういうことか？

例

	1.	もし、雨が降っているなら
	•	傘を持つ
	•	もし、傘を持っているなら
	•	雨具を着る

この場合、「雨が降っているなら、傘を持つ」という条件がまずあり、その後で「傘を持っているなら、雨具を着る」という条件が続いている。

このように、一つの条件が成立した場合、その次の条件がさらにチェックされるのが連続している条件。






<＄SESSIOのtitleやcommentの中にデータを入れてきたのに、最終的に変数、$title や $comment にデーターを入れた理由>
PHPコードの中で、セッション変数から一時的なローカル変数にデータを移す理由は、処理の分かりやすさや効率性、セキュリティなどの複数の要因がある。
セッション変数はユーザーの入力データを保持するために使い、ローカル変数は特定の処理（ここではデータベースへの保存）を効率的に行うために使われる。

セッション変数とローカル変数の役割
1. セッション変数の役割

	•	セッション変数 ($_SESSION['title'] や $_SESSION['comment']) は、ユーザーがページを移動してもデータを保持するために使わる。
	•	ユーザーがフォームに入力したデータを保持し、エラーメッセージが表示された場合でも入力内容を再表示するために使われる。

2. ローカル変数の役割

	•	ローカル変数 ($title や $comment) は、データベースに保存する際や、一時的にデータを処理するために使われる。
	•	データベース操作や他の処理では、セッション変数を直接操作するよりも、ローカル変数を使った方がコードがシンプルで分かりやすくなる。





<セッションのデータを直接、データベースに保存せずに、一度、変数に代入してから保存する理由>
if ($_SESSION['title'] != '' && $_SESSION['comment'] != '' && $imagePath !== false) {
                $title = $_SESSION['title'];
                $comment = $_SESSION['comment'];
                $userId = $_SESSION['user_id'];  // ログインユーザーIDを取得
                $this->db->insertPost($title, $comment, $userId, $imagePath);
                unset($_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path']);
            }

このコードでは、$_SESSION から取り出した値を、$title、$comment、$userId という変数に一度代入しています。このように一度変数に代入する理由を、プログラミング初学者向けに説明します。

理由1: コードの読みやすさ・理解しやすさ

プログラムを読んだり書いたりするとき、変数名はとても大切です。変数名がわかりやすいと、プログラムの意図や動きを理解しやすくなります。

たとえば、$_SESSION['title'] は、セッションの中に保存されたタイトルですが、毎回 $_SESSION['title'] と書くと、何をしているのか直感的にわかりにくくなります。これを $title という変数に代入することで、タイトルを扱っているんだなとすぐにわかるようになります。

理由2: コードの保守性

もし、後で $_SESSION['title'] を他のデータから取得するように変更したい場合、一度変数に代入しておくことで、変更が必要な箇所が減ります。

たとえば、$title という変数に代入した後に使っていれば、変数に代入する部分だけを修正すればよいですが、もし $_SESSION['title'] を直接使っていると、そのコードが複数箇所にある場合、すべて修正しなければなりません。

理由3: 可読性の向上と誤りの防止

長いコードや複雑な処理で $_SESSION['title'] などを何度も書くと、タイプミスが起きやすくなります。変数に代入しておけば、タイプミスのリスクが減り、コードがすっきりして読みやすくなります。

まとめ

このように、一度変数に代入することで、コードが読みやすくなり、後で修正しやすくなり、ミスが減りやすくなるという利点があります。プログラムを簡潔かつ明確に保つための、良い習慣の一つです。





<PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC, // データをカラム名をキーとする連想配列で取得する　の意味>
このコードは、データベースから取り出したデータを「連想配列」として取得するための設定。
「カラム名をキーとする」とは、データベースから取得したデータを連想配列として扱う際に、データベースのカラム名（列の名前）を配列のキー（識別子）として使うことを意味する。以下に具体例。
$users = [
    [
        'id' => 1,
        'name' => '太郎',
        'age' => 10
    ],
    [
        'id' => 2,
        'name' => '花子',
        'age' => 12
    ]
];






<$post_list = $stmt->fetchAll(PDO::FETCH_ASSOC); // 投稿情報を辞書形式ですべて取得の意味>

基本構文
try {
    // エラーが発生するかもしれないコード
} catch (Exception $e) {
    // エラーが発生した場合の処理
}

1.	PDOクラスのインスタンス作成:
$pdo = new PDO('dsn', 'username', 'password', options);
•dsn: データソース名。データベースの種類、ホスト名、データベース名などを含む。
•username: データベースユーザー名。
•password: データベースパスワード。
•options: 配列形式で接続オプションを指定（省略可能）。
2.	例外処理設定:
PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION
3.	プリペアドステートメント設定:
PDO::ATTR_EMULATE_PREPARES => false


<PDO::ATTR_ERRMODE と PDO::ERRMODE_EXCEPTION の詳細説明>






<スローとは>
「スロー（throw）」は、エラーや例外が発生したことを通知するための動作です。PDO::ERRMODE_EXCEPTIONを設定すると、PDOがエラーに遭遇した際に自動的に例外をスローし、その例外をcatchブロックで処理することができます。この仕組みにより、エラーを適切にハンドリングし、プログラムの安定性を確保することができます。






<SQLインジェクション対策>
$title = $_POST['post_title'];
$comment = $_POST['post_comment'];
•説明：フォームから送信されたタイトルとコメントを取得する。
•例え：ユーザーが「タイトル」と「コメント」を紙に書いてPHPに渡す。

$pdo = new PDO(DB_HOST, DB_USER, DB_PASSWORD, [
    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_EMULATE_PREPARES => false,
]);
•説明：データベースに接続します。PDOを使って接続し、エラーモードとプリペアドステートメントの設定を行います。
•例え：PHPがデータベースというお店に入って、特別な「安全な接続パス」を用意します。

$sql = ('
    INSERT INTO
    board_info (title, comment, contributor_id)
    VALUES
    (:TITLE, :COMMENT, :CONTRIBUTOR_ID)
');
$stmt = $pdo->prepare($sql);
•説明：SQLクエリを準備しますが、まだ具体的なデータは入れていません。
•例え：データベースに「これから入れるデータのための空の箱」を用意します。

$stmt->bindValue(':TITLE', $title, PDO::PARAM_STR);
$stmt->bindValue(':COMMENT', $comment, PDO::PARAM_STR);
$stmt->bindValue(':CONTRIBUTOR_ID', $cont_id, PDO::PARAM_STR);
•説明：プレースホルダーにユーザーが入力したデータをバインドします。
•例え：箱に「タイトル」と「コメント」を安全に入れていきます。

$stmt->execute();
•説明：データベースにデータを送信して保存します。
•例え：箱をデータベースに送って、「タイトル」と「コメント」を安全に保存します。


「空の箱」は、最初に用意する「質問の形（SQLクエリ）」を指します。この箱に後から「タイトル」と「コメント」を安全に入れる（バインドする）ことで、最終的にデータベースに送る準備が整います。箱は同じもので、準備してからデータを入れるという二段階のプロセスを表現しています。

・悪い例
$username = $_POST['username'];
$password = $_POST['password'];
説明：フォームからユーザー名とパスワードを取得します。
例え：ユーザーが「user123」と「pass123」というメモをPHPに渡します。

$sql = "SELECT * FROM users WHERE username = '$username' AND password = '$password'";
説明：ユーザーの入力を直接SQLクエリに埋め込みます。
例え：ユーザー名とパスワードを直接、データベースに送る準備をします。

$stmt = $pdo->query($sql);
説明：データベースにクエリを送ります。
例え：データベースに直接データーを渡す。

まとめ
説明：ユーザーの入力データが直接SQLクエリに埋め込まれています。
例え：ユーザー名とパスワードを直接データベースに送るための箱がない状態です。不正なデータがそのまま送られる危険があります。






<セッションを使うメリット>
セッションを使うと異なるスクリプト間でデータが共有される。






<プロパティへのアクセス>
インスタンス->プロパティ名とすることで、そのインスタンスのプロパティにアクセスすることができる（プロパティ名に$は不要）

$this->sessionManager = new SessionManager();






<メソッドの使い方>
メソッドは「public function メソッド名()」のように定義する
また、「インスタンス->メソッド名()」のようにメソッドにアクセスする（メソッドを呼び出す）ことができる。






<命名方法>
動詞 + 名詞の形式: 多くのプログラミング言語では、メソッドや関数の名前はそのメソッドが何をするかを表すために、動詞 + 名詞の形式がよく使われます。handleは「処理する」という意味の動詞で、PostRequestは「POSTリクエスト」を指します。






<CSRF とは何か？>
CSRF攻撃は、ユーザーが意図していない操作を別のサイトから行わせる攻撃。そのため、トークンという「鍵」を使用して、その操作が本当にユーザー自身が行ったものかを確認する。このトークンは、ユーザーがウェブサイトにアクセスしたり、ログインしたと同時に生成され、そのユーザーのセッションに保存される。

CSRF とは、ユーザーが意図しない操作をウェブサイトで実行させてしまう攻撃手法のこと。たとえば、あなたがあるウェブサイトにログインしていて、そのまま他のウェブサイトを見ているとする。このとき、悪意のある第三者が仕掛けた罠によって、あなたのアカウントで何かが実行されてしまうことがある。

具体的な例

	1.	シナリオ
例えば、銀行のウェブサイトにログインしているとします。この銀行サイトで「お金を誰かに送金する」ボタンがあるとします。
	2.	悪意あるページ
その後、あなたは別のページ（悪意のあるページ）にアクセスしてしまいます。このページには、「送金ボタン」が隠れていて、あなたがページを表示しただけで、自動的に送金リクエストが銀行サイトに送信される仕組みが作られているかもしれません。
	3.	被害発生
あなたはそのページを見ただけなのに、銀行サイトではあなたのアカウントから誰かにお金が送られてしまうかもしれません。これは、銀行サイトがそのリクエストが本当にあなたからのものかを確認せずに処理してしまうために起こります。

どうして起こるのか？

CSRF は、ウェブサイトが「どこからのリクエストか」を確認しないことで起こる。たとえば、ブラウザには「クッキー」という仕組みがあり、ログインしているかどうかなどの情報を保存している。攻撃者はこのクッキーを悪用して、ユーザーになりすましたリクエストをサーバーに送るのです。

CSRF を防ぐためには？

このような攻撃を防ぐために、ウェブサイト側で CSRF トークンを使う。

	•	CSRF トークン
トークンとは、一度限りの「鍵」のようなものです。フォームや重要な操作をするときに、このトークンを一緒に送ることで、サーバー側は「このリクエストが正当なものか」を確認します。
	•	仕組み
ウェブページが表示されるときに、サーバーは一意のトークン（たとえば「abcdef123456」みたいなランダムな文字列）を生成します。このトークンは、そのユーザーのセッションに一時的に保存されます。フォームを送信するときに、このトークンも一緒に送信されます。サーバーがリクエストを受け取ったときに、このトークンが正しいかどうか（セッションに保存されているものと一致するかどうか）を確認し、一致しない場合はリクエストを拒否します。
	•	CSRF トークンの役割
これにより、たとえ攻撃者がリクエストを送ったとしても、正しいトークンを持っていなければサーバーはそのリクエストを無効にするため、安全が保たれます。

まとめ

	•	CSRF は、ユーザーが意図しない操作を勝手に実行させる攻撃のこと。
	•	CSRF トークン は、それを防ぐためのセキュリティの仕組み。リクエストが正当なものかを確認するために使われる「一度限りの鍵」。

この仕組みを使うことで、ウェブアプリケーションの安全性を高め、悪意のある攻撃からユーザーを守ることができる。
