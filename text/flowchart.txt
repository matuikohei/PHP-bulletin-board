<board.php>
セッション管理の開始
- `SessionManager->startSession()`
↓
ログイン状態の確認
- `SessionManager->isLoggedIn()`
    - ログインしていない場合:
        - `header('Location: login.php');` へリダイレクト
        - `exit();` で処理終了
↓
ページ番号の取得
- `$_GET['page']` を使用
↓
表示件数（limit）の設定
↓
検索キーワードの取得
- `$_GET['keyword']` を使用
↓
Board クラスのインスタンス作成
- `new Board()`
↓
ユーザーの投稿リクエストを処理
- `Board->handlePostRequest()`
↓
検索キーワードの有無による処理の分岐
- 検索キーワードがある場合:
    - `Board->searchPosts($keyword, $page, $limit)` で投稿の検索結果を取得
    - `Board->countSearchResults($keyword)` で検索結果の総投稿数を取得
- 検索キーワードがない場合:
    - `Board->getPosts($page, $limit)` で指定ページの投稿一覧を取得
    - `Board->getTotalPostCount()` で総投稿数を取得
↓
CSRFトークンの生成
- `Board->generateToken()`
↓
ログインしたユーザーのIDを取得
- `$_SESSION['user_id']` を使用
↓
総投稿数をもとに総ページ数を計算
- `ceil($total_posts / $limit)` を使用
↓
HTMLの生成と表示
- 投稿フォーム
- 検索フォーム
- 投稿リスト
- ページ





<Database.php フローチャート>
[Databaseクラスのインスタンス生成]
    |
    v
[ConfigクラスからDSN、ユーザー名、パスワードを取得]
$dsn = Config::DB_HOST;
$username = Config::DB_USER;
$password = Config::DB_PASSWORD;
    |
    v
[PDOオブジェクトの生成 (try-catch)]
public function __construct()
    {
        // DSNの設定をConfigクラスから読み込む
        $dsn = Config::DB_HOST;
        $username = Config::DB_USER;
        $password = Config::DB_PASSWORD;

        try {
            $this->pdo = new PDO($dsn, $username, $password, [
                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                PDO::ATTR_EMULATE_PREPARES => false,
            ]);
        } catch (PDOException $e) {
            // エラーメッセージを表示
            echo '接続失敗: ' . $e->getMessage();
            exit();
        }
    }

上記のコードで、Database.phpのpdoの中にPDOオブジェクトを格納している。

<tryブロック>
try {
    $this->pdo = new PDO($dsn, $username, $password, [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_EMULATE_PREPARES => false,
    ]);
}

#例え
あなたがホテルにチェックインしようとしているとします。チェックインカウンターに行って、部屋の予約確認をしますね。この部分が「tryブロック」に相当します。「試してみる」段階です。
#PDOインスタンスの作成
new PDO($dsn, $username, $password, [...]) は、データベースに接続するための新しい「鍵」を作る作業。鍵（PDOオブジェクト）を使ってデータベース（ホテルの部屋）にアクセスできるようにする。
#オプション設定
・PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION: これは、「部屋がない」とか「予約が見つからない」（データーベースがない）といったエラーが発生したときに、すぐにスタッフ（PDO）に知らせる設定。
・PDO::ATTR_EMULATE_PREPARES => false: これは、ホテルのスタッフ（PDO）が正確に予約内容を確認するようにするための設定。

<catchブロック>
catch (PDOException $e) {
    echo '接続失敗: ' . $e->getMessage();
    exit();
}
#例え
チェックインを試みたけど、予約が見つからなかった場合どうしますか？カウンターで「予約が見つかりません」と伝えられるでしょう。この部分が「catchブロック」に相当します。

#エラー処理
・catch (PDOException $e): これは、もしチェックインがうまくいかなかったら（例: 予約が見つからなかったら）、エラーメッセージをキャッチして処理します。
・echo '接続失敗: ' . $e->getMessage();: ここでは、エラーメッセージを表示します。「接続失敗: 〇〇」という形で、何が問題だったかを教えてくれます。
・exit();: そして、そこで処理を終了します。これ以上進めることができないためです。

    |
    +--> [成功: PDOオブジェクトを生成して保持]
    |
    +--> [失敗: 例外をキャッチしてエラーメッセージを表示]
    |
    v
[リクエストに基づいて処理を選択]
    |
    +--> [insertPost()]
    |      |
    |      v
    |    [SQL文の準備]
    |      |
    |    [パラメータのバインド]
    |      |
    |    [クエリの実行]
    |      |
    |    [完了]
    |
    +--> [fetchAllPosts()]
    |      |
    |    [SQL文の準備]
    |      |
    |    [クエリの実行]
    |      |
    |    [結果を配列で返す]
    |      |
    |    [完了]
    |
    +--> [searchPosts()]
    |      |
    |    [SQL文の準備]
    |      |
    |    [パラメータのバインド]
    |      |
    |    [クエリの実行]
    |      |
    |    [結果を配列で返す]
    |      |
    |    [完了]
    |
    +--> [fetchPostsByPage()]
    |      |
    |    [SQL文の準備]
    |      |
    |    [パラメータのバインド]
    |      |
    |    [クエリの実行]
    |      |
    |    [結果を配列で返す]
    |      |
    |    [完了]
    |
    +--> [countAllPosts()]
    |      |
    |    [SQL文の準備]
    |      |
    |    [クエリの実行]
    |      |
    |    [投稿総数を返す]
    |      |
    |    [完了]
    |
    +--> [deletePost()]
    |      |
    |    [画像パス取得]
    |      |
    |    [画像削除 (unlink)]
    |      |
    |    [SQL文の準備]
    |      |
    |    [パラメータのバインド]
    |      |
    |    [クエリの実行]
    |      |
    |    [完了]
    |

<insertPostメソッド>
# 呼び出しもと
呼び出しもとは、Boardクラス。タイトル、コメントが入力されており、画像アップロードに成功していればinsertPostメソッドを使って、投稿をデータベースに保存

if ($_SESSION['title'] != '' && $_SESSION['comment'] != '' && $imagePath !== false) {
    $title = $_SESSION['title'];
    $comment = $_SESSION['comment'];
    $userId = $_SESSION['user_id'];  // ログインユーザーIDを取得
    $this->db->insertPost($title, $comment, $userId, $imagePath);
    unset($_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path']);
}


# データの準備：箱にデータを入れる
public function insertPost($title, $comment, $user_id, $imagePath)

-説明
この部分は、insertPostメソッドの宣言です。ここで、$title、$comment、$user_id、$imagePathという4つのデータを引数として受け取ります。これらのデータは、後でデータベースに送るために使います。このデータが、例え話の「貴重なデータ」であり、これから箱に詰めるものです。

-例え：
あなたがいくつかのデータ（タイトル、コメント、ユーザーID、画像パス）を持っているとしましょう。それぞれのデータは、貴重なもので、正確に安全に届ける必要があります。このデータを、安全な「箱」に入れて送ることにします。


# SQL文を準備（SQLステートメント、SQLへの命令文、プレースホルダーの準備）：箱のラベルを作る
$stmt = $this->pdo->prepare('INSERT INTO board_info (title, comment, user_id, image_path) VALUES (:title, :comment, :user_id, :image_path)');

-説明
この行では、データベースに送るためのSQL文を準備しています。prepareメソッドを使って、SQL文の「テンプレート」を作ります。VALUES (:title, :comment, :user_id, :image_path)の部分が、箱のラベルにあたります。ここでは具体的なデータはまだ入っておらず、どのデータがどこに入るかを示す「プレースホルダ」と呼ばれるものが使われています。
$stmtという変数名は、ステートメントを意味しています。ステートメントとは命令文のことです。
prepareメソッドは、プレースホルダーを準備するためのメソッド。

-例え：
次に、データを送るための「箱」のラベルを作ります。このラベルには、何が入っているのかが書かれていますが、まだ具体的なデータは書かれていません。例えば、「タイトルを入れる場所」「コメントを入れる場所」などと書かれています。このラベルがSQL文のテンプレートに相当します。


# データを箱に詰める：プレースホルダにデータを入れる
$stmt->bindValue(':title', $title, PDO::PARAM_STR);
$stmt->bindValue(':comment', $comment, PDO::PARAM_STR);
$stmt->bindValue(':user_id', $user_id, PDO::PARAM_INT);
$stmt->bindValue(':image_path', $imagePath, PDO::PARAM_STR);

-説明
この部分では、受け取ったデータをSQL文のプレースホルダに詰めています。bindValueメソッドを使って、$title、$comment、$user_id、$imagePathのデータをそれぞれ:title、:comment、:user_id、:image_pathというプレースホルダに代入しています。これが、データを箱の中の指定された場所に詰める作業にあたります。
bindValueメソッドは、SQL文に含まれるプレースホルダー（:で始まる部分）に実際のデータを結びつけるためのメソッドです。この結びつける操作を「バインド」と言います。

-例え
次に、準備したラベルに従って、各データを箱の中の適切な場所に詰めます。具体的には、「タイトル」を「タイトル用の場所」に、「コメント」を「コメント用の場所」に入れていきます。このプロセスが、SQL文のプレースホルダにデータを代入する作業にあたります。


#安全に箱を閉じる：SQLインジェクション対策
-説明
ここで重要なのは、bindValueを使うことで、データが適切に保護されている点です。プレースホルダを使うことで、SQLインジェクション攻撃からデータを守ることができます。これが、箱をしっかり閉じて、安全に保つという部分にあたります。

-例え
この箱にはしっかりと蓋がされており、外部から箱の中身に触れられないようになっています。これがSQLインジェクション対策に相当します。箱がしっかりと閉じられていることで、データが改ざんされたり、悪意のあるコードが紛れ込んだりすることを防ぎます。


# 箱をデータベースに送る：SQL文の実行
$stmt->execute();

-説明
最後に、executeメソッドを使って、準備が整ったSQL文を実行します。これにより、データベースに箱を送り、その中のデータがデータベースに保存されます。データベース側では、送られてきたデータを適切な場所に保存する処理が行われます。
executeメソッドは、prepareとbindValueで準備したSQL文を実際にデータベースに送って、処理を実行するためのメソッドです。

-例え
最後に、この安全な箱をデータベースに送ります。データベースは、この箱を受け取り、ラベルを見て、中に入っているデータを正しい場所に保存します。これがSQL文を実行して、データベースにデータを保存するプロセスです。


<fetchAllPostsメソッド 今は使っていない>
まず、このコードはPHPでデータベースから投稿情報を取得するためのメソッド（関数）です。

# データベースクエリの準備
$stmt = $this->pdo->prepare('SELECT * FROM board_info ORDER BY id DESC');

-説明
この行は、データベースに対してSQLクエリ（命令）を準備する部分です。
$this->pdo: これは、PDO（PHP Data Objects）というPHPのデータベースアクセスクラスのインスタンスです。このインスタンスを使ってデータベースに接続し、操作を行います。
prepareメソッドは、プレースホルダーを準備するためのメソッド。
SELECT *: SQLの命令で、「すべての列を選択する」という意味です。
FROM board_info: board_info という名前のテーブルからデータを取得します。
ORDER BY id DESC: id という列を基準にして、データを降順（大きい順）に並べ替えて取得します。

-例え
これは、書店のカウンターで「棚にある本をすべて持ってきて、IDが大きい順に並べてください」と注文しているようなものです。

# クエリの実行
$stmt->execute();

-説明
この行は、準備したSQLクエリをデータベースに送信して実行する部分です。
execute() メソッドを呼び出すことで、データベースが指示に従ってデータを取得します。

-例え
先ほどの書店の例で言うと、店員が注文票を見て、実際に棚から本を取り出す作業を開始するようなものです。

# 結果の取得と返却
return $stmt->fetchAll(PDO::FETCH_ASSOC);

-説明
この部分は、データベースから取得した結果を配列の形で取得し、そのまま呼び出し元に返す部分です。
fetchAll() メソッドは、クエリの結果をすべて取得し、配列として返します。
PDO::FETCH_ASSOC:。このオプションは、データを連想配列の形式で取得することを意味します。連想配列とは、キー（列名）と値（データ）がペアになった配列です。

-具体的にどのような形で帰ってくるか
[
    [
        "id" => 1,
        "title" => "掲示板の初投稿",
        "comment" => "これは初めての投稿です。",
        "user_id" => 101,
        "image_path" => "uploads/image1.jpg",
        "created_at" => "2024-08-01 12:34:56",
        "updated_at" => "2024-08-01 13:00:00"
    ],
    [
        "id" => 2,
        "title" => "PHPについて",
        "comment" => "PHPの質問です。",
        "user_id" => 102,
        "image_path" => "uploads/image2.jpg",
        "created_at" => "2024-08-02 14:20:00",
        "updated_at" => "2024-08-02 15:00:00"
    ],
    // さらに多くの投稿データが続く
]

-例え
これは、取り出した本の一覧をタイトルや著者名などの情報を含めたリストに整理し、それを注文した人に渡すような作業です。



<searchPostsメソッド>
public function fetchPostsByPage($page, $limit)
    {
        $offset = ($page - 1) * $limit;
        $stmt = $this->pdo->prepare('SELECT * FROM board_info ORDER BY id DESC LIMIT :limit OFFSET :offset');
        $stmt->bindValue(':limit', $limit, PDO::PARAM_INT);
        $stmt->bindValue(':offset', $offset, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
#処理の流れ
board.php → Board.php searchPostsメソッド → Database.php searchPostsメソッド

#メソッドの役割
この searchPosts メソッドは、掲示板アプリケーション内で、ユーザーが入力したキーワードに基づいて投稿を検索し、その検索結果をページごとに表示するための機能を提供します。

#メソッド宣言部分
public function searchPosts($keyword, $page, $limit)

-説明
$keyword:
ユーザーが検索ボックスに入力したキーワード。これを基に、タイトルやコメントの中から一致する投稿を検索します。
$page:
現在表示するページ番号。ページネーション（複数ページに分割して表示）を実現するために使います。
$limit:
1ページに表示する投稿の数。例えば、1ページに10件表示する場合、この値は10になります。

#オフセットの計算
$offset = ($page - 1) * $limit;

-説明
このコードは、データベースからデータを取得するときに、「どこからデータを取り始めるか」を計算しています。具体的には、ページネーションと呼ばれる機能を実現するために使われます。このコードは、データベースからどの位置からデータを取り始めるかを決めるために使われます。ページネーションを実現するために、特定のページに表示するデータのスタート位置を計算しています。

-具体例
1ページ目:
$page = 1 のとき、$offset は (1 - 1) * 10 = 0 です。つまり、最初のデータから表示を始めます。
2ページ目:
$page = 2 のとき、$offset は (2 - 1) * 10 = 10 です。つまり、11番目のデータから表示を始めます。
3ページ目:
$page = 3 のとき、$offset は (3 - 1) * 10 = 20 です。つまり、21番目のデータから表示を始めます。

#SQLクエリの準備
$stmt = $this->pdo->prepare(
    'SELECT * FROM board_info
     WHERE title LIKE :keyword1 OR comment LIKE :keyword2
     ORDER BY id DESC
     LIMIT :limit OFFSET :offset'
);

#SQLクエリ:
•SELECT * FROM board_info: board_info テーブルからすべての列（データ）を選択するという意味です。
•WHERE title LIKE :keyword1 OR comment LIKE :keyword2: ここでは、投稿のタイトルまたはコメントがキーワードと一致するものを検索しています。LIKE は部分一致検索を行うための条件です。
•ORDER BY id DESC: 検索結果を投稿IDの降順（新しいものが上）で並べ替えます。
•LIMIT :limit OFFSET :offset: 取得する投稿の数を制限し、どこから取得を始めるかを指定します。これにより、ページごとに投稿を表示できます。

#SQLクエリとCRUD操作の対応
-Create（作成）:
•SQLクエリ: INSERT INTO を使います。
•例: INSERT INTO users (username, password) VALUES ('john_doe', 'secret');
-Read（読み取り）:
•SQLクエリ: SELECT を使います。
•例: SELECT * FROM users WHERE username = 'john_doe';
-Update（更新）:
•SQLクエリ: UPDATE を使います。
•例: UPDATE users SET password = 'new_secret' WHERE username = 'john_doe';
-Delete（削除）:
•SQLクエリ: DELETE を使います。
•例: DELETE FROM users WHERE username = 'john_doe';

#結果の取得
return $stmt->fetchAll(PDO::FETCH_ASSOC);

-説明
•クエリの実行結果をすべて取得し、連想配列として返します。
•fetchAll() メソッドは、クエリの結果をすべて取得し、配列として返します。
•PDO::FETCH_ASSOC: これは、結果を連想配列の形式で取得することを意味します。連想配列とは、キー（列名）と値（データ）がペアになった形式です。


<countSearchResultsメソッド>
public function countSearchResults($keyword)
    {
        $stmt = $this->pdo->prepare('SELECT COUNT(*) FROM board_info WHERE title LIKE :keyword1 OR comment LIKE :keyword2');
        $stmt->bindValue(':keyword1', '%' . $keyword . '%', PDO::PARAM_STR);
        $stmt->bindValue(':keyword2', '%' . $keyword . '%', PDO::PARAM_STR);
        $stmt->execute();
        return $stmt->fetchColumn();
    }

#処理の流れ
board.php（ページネーションの総ページ数の表示に使用） → Board.php countSearchResultsメソッド → Database.php countSearchResultsメソッド

#SQLクエリの準備
$stmt = $this->pdo->prepare('SELECT COUNT(*) FROM board_info WHERE title LIKE :keyword1 OR comment LIKE :keyword2');

-説明
•ここでは、データベースに対して実行するSQLクエリを準備しています。
•SQL文の意味:
SELECT COUNT(*): これは、条件に一致する行（データ）がいくつあるかを数えるためのSQL文です。
FROM board_info: board_info というテーブルからデータを取得します。このテーブルには掲示板の投稿が保存されています。
WHERE title LIKE :keyword1 OR comment LIKE :keyword2: ここで、投稿のタイトルまたはコメントに、ユーザーが入力したキーワードが含まれているかどうかを調べます。

#戻り値
return $stmt->fetchColumn();

-fetchColumn メソッド:
fetchColumn は、クエリの結果から最初の列の値を取得するためのメソッドです。この場合は、COUNT(*) の結果（つまり、キーワードに一致する投稿の数）が返されます。



<fetchPostsByPageメソッド>
#処理の流れ
board.php $post_list → Board.php getPostメソッド → Database.php fetchPostsByPageメソッド

public function fetchPostsByPage($page, $limit)
    {
        $offset = ($page - 1) * $limit;
        $stmt = $this->pdo->prepare('SELECT * FROM board_info ORDER BY id DESC LIMIT :limit OFFSET :offset');
        $stmt->bindValue(':limit', $limit, PDO::PARAM_INT);
        $stmt->bindValue(':offset', $offset, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

#メソッドの概要
public function fetchPostsByPage($page, $limit)
-説明
・$page:
現在表示したいページ番号を指定します。たとえば、1ページ目、2ページ目など。
・$limit:
1ページに表示する投稿の数を指定します。たとえば、1ページに10件の投稿を表示する場合、この値は10になります。

#オフセットの計算
$offset = ($page - 1) * $limit;

-$page - 1をする理由
$offset = ($page - 1) * $limit; という計算において、$page から1を引くのは、ページネーションの仕組みを正しく動作させるためです。

-ページネーションの基本
ページネーションとは、データを複数のページに分けて表示する機能です。たとえば、1ページに10件のデータを表示する場合、次のようになります。
•	1ページ目: 1件目から10件目まで
•	2ページ目: 11件目から20件目まで
•	3ページ目: 21件目から30件目まで

-オフセットとは
オフセット（$offset）は、データベースからデータを取得するときに、「何件目から取得を始めるか」を指定するためのものです。

-($page - 1) の意味

$page は現在のページ番号を示しますが、データを取得するときのオフセットを計算する際には、$page から1を引いて計算する必要があります。

-理由
•1ページ目の場合: $page が1なので、($page - 1) * $limit は (1 - 1) * $limit となり、0 になります。つまり、データベースから最初のデータ（1件目）から取得を開始します。
•2ページ目の場合: $page が2なので、($page - 1) * $limit は (2 - 1) * $limit となり、$limit そのものがオフセットになります。たとえば、$limit が10なら、オフセットは10です。これは、データベースから11件目からデータを取得することを意味します。

-具体例
たとえば、1ページに10件のデータを表示する場合を考えます。
•1ページ目:
•$page = 1
•オフセット: ($page - 1) * $limit = (1 - 1) * 10 = 0
•0番目（1件目）からデータを取得

•2ページ目:
•$page = 2
•オフセット: ($page - 1) * $limit = (2 - 1) * 10 = 10
•10番目（11件目）からデータを取得

•3ページ目:
•$page = 3
•オフセット: ($page - 1) * $limit = (3 - 1) * 10 = 20
•20番目（21件目）からデータを取得

-まとめ
•($page - 1) で1を引くのは、データ取得の開始位置（オフセット）を正しく計算するためです。
•1ページ目の場合はオフセットが 0 になり、最初のデータから取得を開始します。2ページ目以降では、前のページに表示したデータ数分だけオフセットを設定し、その次のデータから取得を始めます。

この計算により、ページネーションが正しく機能し、ユーザーが見るページに適切なデータが表示されるようになります。

#SQLクエリの準備
$stmt = $this->pdo->prepare('SELECT * FROM board_info ORDER BY id DESC LIMIT :limit OFFSET :offset');
このコードでは、board_infoの何件目の情報（offset）から、何件分（limit）の情報を持ってくるのかを決めている

-説明
•ORDER BY id DESC:
id を基準に投稿を降順（つまり、新しいものが最初に来る順）で並べ替えます。
•LIMIT :limit:
取得するデータの最大件数を指定します。例えば、LIMIT 10 とバインドされた場合、10件のデータを取得します。
•OFFSET :offset:
データの取得を開始する位置を指定します。例えば、OFFSET 0 とバインドされた場合、最初のデータ（最新のデータ）から取得します。

#プレースホルダーへの値のバインド
$stmt->bindValue(':limit', $limit, PDO::PARAM_INT);
$stmt->bindValue(':offset', $offset, PDO::PARAM_INT);

-説明
prepareメソッドで、箱のラベルを作って、どの情報（命令文）をどこの箱に入れるか決めておいたものを、bindValueで、どこに入れるか決めておいた箱に情報（命令文）を入れて、executeメソッドでその情報が入った箱をデーターベースへ送る

#結果の取得
return $stmt->fetchAll(PDO::FETCH_ASSOC);

-説明
•fetchAll(PDO::FETCH_ASSOC):
この部分では、データベースから返ってきた「箱」の中身を取り出す作業を行っています。
fetchAll() は、返ってきたすべてのデータを取得するためのメソッドです。これは、「箱の中に入っているすべてのデータを取り出してください」という命令に相当します。


<countAllPostsメソッド>
public function countAllPosts()
    {
        $stmt = $this->pdo->query('SELECT COUNT(*) FROM board_info');
        return $stmt->fetchColumn();
    }

#メソッドの概要
public function countAllPosts()
    {
        $stmt = $this->pdo->query('SELECT COUNT(*) FROM board_info');
        return $stmt->fetchColumn();
    }
この countAllPosts メソッドは、掲示板などのアプリケーションで「すべての投稿がいくつあるのか」を数えて、その数を返します。

#処理の流れ
board.php $total_posts変数 getTotalPostCountメソッド呼び出し → Board.php getTotalPostCountメソッド → Database.phpのcountAllPostsメソッドの呼び出し

#SQLクエリ
$stmt = $this->pdo->query('SELECT COUNT(*) FROM board_info');
-説明
行数を数えるだけで、データー改竄の恐れがなく、SQLインジェクション対策を行う必要がないためprepareではなく、queryを使用している

#結果の取得
return $stmt->fetchColumn();
-説明
fetchColumn() は、クエリの結果の最初の列を取得するメソッドです。この場合、COUNT(*) の結果、つまり投稿の総数を取得します。


<getImagePathメソッド>
public function getImagePath($post_id)
{
    $stmt = $this->pdo->prepare('SELECT image_path FROM board_info WHERE id = :id');
    $stmt->bindValue(':id', $post_id, PDO::PARAM_INT);
    $stmt->execute();
    return $stmt->fetchColumn();
}

#処理の流れ
DeleteConfirmクラスのhandleRequestメソッド → handleRequestメソッドでDatabaseクラスのdeletePostメソッドの呼び出し → deletePostメソッドでgetImagePathメソッドを呼び出し

#メソッドの概要
このメソッドは、掲示板アプリケーションの中で、投稿ID（post_id）を使って、その投稿に関連する画像のファイルパスをデータベースから取得し、そのパスを返します。つまり、「特定の投稿に紐づいた画像の場所」を探し出すためのものです。

#メソッドの定義
public function getImagePath($post_id)
-説明
これは、getImagePath という名前のメソッドを定義しています。このメソッドは、投稿のID（$post_id）を受け取り、そのIDに関連する画像のパスをデータベースから取得します。
-例え
これは、図書館で「特定の本（投稿）に付いているラベル（画像のパス）を見つける」作業を行うようなものです。

#SQLクエリ
$stmt = $this->pdo->prepare('SELECT image_path FROM board_info WHERE id = :id');
-説明
この部分では、データベースに対して「board_info というテーブルから、特定の投稿ID（id）に対応する画像のパス（image_path）を取得して欲しい」という命令を準備しています。
-例え
これは、図書館員に「特定の本のラベル（画像のパス）を探して欲しい」とお願いしているようなものです。

#結果の取得
return $stmt->fetchColumn();
-説明
fetchColumn() メソッドは、クエリの結果から最初の列（この場合は image_path）を取得します。


<deletePostメソッド>
public function deletePost($post_id)
    {
        $imagePath = $this->getImagePath($post_id);
        if (!empty($imagePath) && file_exists($imagePath)) {
            unlink($imagePath);
        }

        $stmt = $this->pdo->prepare('DELETE FROM board_info WHERE id = :id');
        $stmt->bindValue(':id', $post_id, PDO::PARAM_INT);
        $stmt->execute();
    }

#処理の流れ
DeleteConfirmクラスのhandleRequestメソッド → handleRequestメソッドでDatabaseクラスのdeletePostメソッドの呼び出し

#メソッドの概要
このメソッド deletePost は、特定の投稿ID（$post_id）を使って、その投稿に関連するデータと画像を削除します。具体的には、投稿に紐づいた画像ファイルをサーバーから削除し、その後にデータベースから投稿のデータを削除します。

#画像パスの取得
$imagePath = $this->getImagePath($post_id);
-説明
ここでは、投稿IDを使って、その投稿に関連する画像ファイルのパスを取得しています。この getImagePathメソッドで、特定の投稿IDに対応する画像の場所をデータベースから探し出します。

#画像ファイルの削除チェック
if (!empty($imagePath) && file_exists($imagePath)) {
    unlink($imagePath);
}
-説明:
ここでは、画像ファイルのパスが空でないか（!empty($imagePath)）を確認し、そのファイルがサーバー上に実際に存在するか（file_exists($imagePath)）を確認しています。もし存在しているなら、その画像ファイルを削除します（unlink($imagePath)）。
empty は、変数が「空」であるかどうかを調べるためのPHPの構文です。具体的には、変数が次のいずれかの状態にある場合に true を返します。
file_exists は、指定されたパスにファイルやディレクトリが存在するかどうかを確認するためのPHPの組み込み関数です。

#画像ファイルの削除
unlink($imagePath);
-説明
unlink は、指定されたファイルをサーバーから削除するためのPHP組み込み関数です。実際にファイルを削除する操作を行います。

#投稿データの削除
$stmt = $this->pdo->prepare('DELETE FROM board_info WHERE id = :id');
$stmt->bindValue(':id', $post_id, PDO::PARAM_INT);
$stmt->execute();
-説明:
ここでは、データベースから指定された投稿IDに対応する投稿データを削除します。まず、DELETE FROM board_info WHERE id = :id というSQL文を準備し（prepare）、次にそのIDに値をバインド（bindValue）します。最後に、このSQL文を実行して投稿データを削除します（execute）。







<Board.php フローチャート>
[開始]
    |
    v
[Boardクラスのインスタンス作成]
board.phpでインスタンスを作成する
    |
    v
[__construct()メソッド呼び出し]
board.phpでインスタンスが生成されると自動でconstructが呼び出される
    |
    v
[SessionManagerインスタンス作成] ---> [セッション開始 (startSession())]
セッションは、サーバー側でユーザーごとのデータを一時的に保持するため箱
    |
    v
[Databaseインスタンス作成]
    |
    v
[ログイン状態を確認 isLoggedIn()メソッドの呼び出し]
isLoggedInメソッドは、SessionManager.phpにある
    |
    v
[ログイン済みか？] --------> [未ログイン] -------> [ログインページにリダイレクト] ---> [終了]
if (!$this->sessionManager->isLoggedIn()) は、isLoggedIn メソッドを使ってユーザーがログインしているかどうかを確認。! は否定演算子で、isLoggedIn() が false を返す（ログインしていない）場合に if 文の内部が実行。
header('Location: login.php'); は、ユーザーがログインしていない場合に、ブラウザを login.php ページにリダイレクトする。
exit(); は、スクリプトの実行をここで終了させる。これにより、未ログインのユーザーが続行することを防ぐ。
    |
    v
[ログイン済み]
    |
    v
[handlePostRequest()メソッド呼び出し]
    |
    v
[POSTリクエストか？（投稿ボタンが押されたか）] --------> [POSTリクエストでない] ---> [終了]
    |
    v
[POSTリクエスト]
if ($_SERVER['REQUEST_METHOD'] === 'POST')
$_SERVERという箱の中に入っている、['REQUEST_METHOD']という情報が、POSTであるか確認している。
    |
    v
[CSRFトークンを検証 (validateToken())]
どのタイミングでトークンが生成されるのか？
board.phpのページに訪れた瞬間にトークンを生成。SessionManager.phpのgenerateTokenメソッドでトークンが生成される。このトークンをBoard.phpでも使えるのはセッションを使っているので、異なるスクリプト(SessionManager.phpやBoard.phpなどのPHPプログラム)で共有されるため

$_POSTという箱の中に入っている、['board_token']という情報。
$_POST['board_token'] は、フォーム送信時に送られてきたトークンのこと。SessionManager.phpのvalidateToken メソッド（工場）に、$_POST['board_token']という材料を渡して、そのトークンが正しいかどうかを確認している

SessionManager.phpのvalidateToken メソッドでは、トークンが正しければ、何も返さずに、違った場合のみ処理を中止させる。
    |
    v
[タイトルが入力されているか？]
    |
    v
[タイトルあり] --------> [タイトルなし] ---> [タイトルのエラーメッセージを設定] ---> [終了]
    |
    v
[コメントが入力されているか？]
    |
    v
[コメントあり] --------> [コメントなし] ---> [コメントのエラーメッセージを設定] ---> [終了]
    |
    v
[画像アップロード処理 (handleImageUpload())]
    |
    v
[タイトル、コメント、画像アップロードが成功しているか？]
    |
    v
[成功している] --------> [失敗している] ---> [終了]
    |
    v
[データベースに投稿を保存 (insertPost())]
if ($_SESSION['title'] != '' && $_SESSION['comment'] != '' && $imagePath !== false) {
    $title = $_SESSION['title'];
    $comment = $_SESSION['comment'];
    $userId = $_SESSION['user_id'];  // ログインユーザーIDを取得
    $this->db->insertPost($title, $comment, $userId, $imagePath);
    unset($_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path']);
}
Database.phpのinsertPostメソッドを使用し、データーベースに、タイトル、コメント、画像、ユーザーIDを保存
    |
    v
[セッションのタイトルとコメント、イメージを削除]
保存が完了した後、unset($_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path']); でこれらのセッション変数を削除。user_id は後の処理で使用するため、削除しない。
    |
    v
[終了]

-------------------------------------------------------------------
[handleImageUpload()メソッド]
private function handleImageUpload() {
        // フォームで画像がアップロードされているか確認し、アップロードにエラーがないか確認
        if (isset($_FILES['post_image']) && $_FILES['post_image']['error'] == UPLOAD_ERR_OK) {
            // アップロードされた画像を保存するディレクトリを指定
            $uploadDir = 'uploads/';
            // 保存先のファイルパスを生成（ディレクトリ + ファイル名）
            $uploadFile = $uploadDir . basename($_FILES['post_image']['name']);

            // アップロードされた画像ファイルを指定したディレクトリに移動
            if (move_uploaded_file($_FILES['post_image']['tmp_name'], $uploadFile)) {
                // 移動に成功した場合、保存先のファイルパスを返す
                return $uploadFile;
            } else {
                // 画像の移動に失敗した場合、エラーメッセージを設定し、falseを返す
                $this->err_msg_image = '画像のアップロードに失敗しました';
                return false;
            }
        }
        return '';
}
    |
    v
[画像がアップロードされたか？]
if (isset($_FILES['post_image']) && $_FILES['post_image']['error'] == UPLOAD_ERR_OK)
$_FILES という箱の中に 'post_image' という名前の情報が入っているかどうかを確認している。
これは、ユーザーが画像ファイルをアップロードしようとした場合、その情報が $_FILES に保存されるため、アップロードが行われたかどうかをチェックするために使われる。

$_FILES['post_image']['error'] == UPLOAD_ERR_OKについて
ユーザーがアップロードした画像ファイルに関するさまざまな情報が $_FILES['post_image'] の中に入っている。

この情報の中には、例えば以下のようなものがある。
'name': ファイルの元の名前
'type': ファイルのタイプ（例えば “image/jpeg” など）
'size': ファイルのサイズ（バイト数）
'tmp_name': サーバーに一時的に保存されたファイルのパス
'error': アップロード中に発生したエラーコード

'error' とは？
'error' は、ファイルのアップロード時に問題が発生したかどうかを示す値。具体的には、アップロードの成功・失敗を表すコードが入ってる。

UPLOAD_ERR_OK とは？
UPLOAD_ERR_OK は、アップロードが成功したことを示す特別な定数（一定の値）。PHP では、アップロードが正常に行われた場合、この 'error' キーには UPLOAD_ERR_OK という値がセットされる。

$_FILES['post_image']の['error']の中にUPLOAD_ERR_OKという情報が入っているかどうかを確認することで、画像が問題なくアップロードされたかを確認している

    |
    v
[アップロード成功] --------> [アップロード失敗またはなし] ---> [エラーメッセージを設定しfalseを返す] ---> [終了]
    |
    v
[画像を指定のディレクトリに保存]
$uploadDir = 'uploads/';
$uploadFile = $uploadDir . basename($_FILES['post_image']['name']);
    |
    v
[画像のパスを返す]
return $uploadFile
この行は、「アップロードしたファイルの保存場所」を返す
$uploadFileという箱に、保存されたファイルのパス（場所）が入っている。
例えば、“uploads/example.jpg” というパスが返されると、その後の処理でそのファイルの場所を使って、画像を表示したり、データベースに保存したりすることができる。

具体的には、handleImageUpload()メソッドで取得した画像のパスは、Board.phpのhandlePostRequestの＄imagePathという箱の中に保存される。
    |
    v
[終了]

-------------------------------------------------------------------

[getPosts()メソッド]
//  指定されたページの投稿を取得するメソッド
public function getPosts($page = 1, $limit = 10) {
    return $this->db->fetchPostsByPage($page, $limit);
}
    |
    v
[データベースから指定されたページの投稿を取得 (fetchPostsByPage())]
getPosts($page, $limit) が呼び出されると、その中で Databese.phpのfetchPostsByPage($page, $limit) が実行
fetchPostsByPage メソッドは、データベースから指定されたページと表示件数に基づいて投稿データを取得
    |
    v
[取得した投稿を返す]
返す先は、呼び出し元の、board.phpの$post_listに格納
$post_list = $board->getPosts($page, $limit);
$post_list にはデータベースから取得された投稿データが格納され、これが掲示板に表示される投稿リストとして使われる
    |
    v
[終了]

-------------------------------------------------------------------

[getTotalPostCount()メソッド]
$total_posts = $board->getTotalPostCount();
board.phpで呼び出される。呼び出されて実行された値は、board.phpの$total_postsに格納される
    |
    v
[データベースから投稿の総数を取得 (countAllPosts())]
Database.phpのcountAllPostsメソッドを呼び出す。処理の結果としてデータベースの board_info テーブル内の投稿数をカウントし、その数を返します
    |
    v
[取得した投稿の総数を返す]
    |
    v
[終了]

-------------------------------------------------------------------

[searchPosts()メソッド]
board.phpで呼び出される。
// 検索キーワードがある場合の処理と通常の投稿取得処理
if (!empty($keyword)) {
    // 検索キーワードがある場合の処理
    $post_list = $board->searchPosts($keyword, $page, $limit); // 検索結果を取得
    $total_posts = $board->countSearchResults($keyword); // 検索結果の総投稿数を取得
} else {
    // 通常の投稿取得処理
    $post_list = $board->getPosts($page, $limit); // 指定されたページの投稿一覧を取得
    $total_posts = $board->getTotalPostCount(); // 総投稿数を取得
}
    |
    v
[データベースから指定されたキーワードで投稿を検索 (searchPosts())]
public function searchPosts($keyword, $page = 1, $limit = 10) {
    return $this->db->searchPosts($keyword, $page, $limit);
}
Database.phpのsearchPostsを呼び出す

引数になっている$keywordはboard.phpの以下の流れで渡される

検索フォームに文字が入力される。method="get"が使われているので、$_GETへ情報が送られる
<form action="board.php" method="get">
                <input type="text" name="keyword" placeholder="検索キーワードを入力">
                <button type="submit" name="search_button">検索</button>
                <?php if (!empty($keyword)): ?>
                    <a href="board.php">全て表示</a>
                <?php endif; ?>
            </form>

送られてきた情報を$keywordに格納
$keyword = isset($_GET['keyword']) ? $_GET['keyword'] : '';

検索結果を持ってくるために作られたsearchPostsを使って、($keyword, $page, $limit)をもとに検索結果を持ってきて、
検索結果を格納するための$post_listという箱に格納される
$post_list = $board->searchPosts($keyword, $page, $limit);
    |
    v
[取得した検索結果を返す]
    |
    v
[終了]

-------------------------------------------------------------------

[countSearchResults()メソッド]
public function searchPosts($keyword, $page = 1, $limit = 10) {
        return $this->db->searchPosts($keyword, $page, $limit);
}
    |
    v
[データベースから検索結果の投稿総数を取得 (countSearchResults())]
    |
    v
[取得した検索結果の総数を返す]
このメソッドは、board.phpで呼び出されて、結果は、$total_postsに格納される
if (!empty($keyword)) {
    // 検索キーワードがある場合の処理
    $post_list = $board->searchPosts($keyword, $page, $limit); // 検索結果を取得
    $total_posts = $board->countSearchResults($keyword); // 検索結果の総投稿数を取得
} else {
    // 通常の投稿取得処理
    $post_list = $board->getPosts($page, $limit); // 指定されたページの投稿一覧を取得
    $total_posts = $board->getTotalPostCount(); // 総投稿数を取得
}
    |
    v
[終了]

-------------------------------------------------------------------

[generateToken()メソッド]
    |
    v
[セッションマネージャーを使ってCSRFトークンを生成 (setToken())]
SessionManager.phpのsetTokenを呼び出す。
    |
    v
[生成されたトークンを返す]
board.phpの$tokenへトークンを返す
$token = $board->generateToken(); // CSRFトークンを生成
    |
    v
[終了]

-------------------------------------------------------------------

[getErrMsgTitle()メソッド]
public function getErrMsgTitle() {
    return $this->err_msg_title;
}

タイトル欄がからの場合は、Board.phpの
if (isset($_POST['post_title']) && $_POST['post_title'] != '') {
    $_SESSION['title'] = $_POST['post_title'];
    } else {
    unset($_SESSION['title']);
    $this->err_msg_title = '※タイトルを入力して下さい';
}
このコードの処理によって、private $err_msg_title = '';にタイトルを入力して下さいと格納して結果を返す。
タイトルが記載されている場合は、private $err_msg_title = '';を空の箱のまま返す。
    |
    v
[タイトルのエラーメッセージを返す]
このメソッドはboard.phpで呼び出される。
board.phpのコードでは、$err_msg_titleが空の場合は、何も処理をしないで、$err_msg_titleに文字が入力されている場合のみ処理を行う
<label>
    <p>タイトル（※最大30文字）</p>
    <input type="text" name="post_title" value="<?php if (isset($_SESSION['title'])) echo htmlspecialchars($_SESSION['title'], ENT_QUOTES, 'UTF-8'); ?>">
    <!-- タイトルのエラーメッセージ表示 -->
    <?php if (!empty($board->getErrMsgTitle())) {
        echo "<p class='err'>" . htmlspecialchars($board->getErrMsgTitle(), ENT_QUOTES, 'UTF-8') . "</p>";
    } ?>
</label>


    |
    v
[終了]

-------------------------------------------------------------------

[getErrMsgComment()メソッド]
上のタイトルのメソッドと流れは同じ
    |
    v
[コメントのエラーメッセージを返す]
    |
    v
[終了]

-------------------------------------------------------------------

[getErrMsgImage()メソッド]
基本的な流れは上と同じ。だけどエラーメッセージを作成するコードは、別の場所
    |
    v
[画像のエラーメッセージを返す]
    |
    v
[終了]

-------------------------------------------------------------------

[deletePost()メソッド]
public function deletePost($post_id) {
        $this->db->deletePost($post_id);
}

このコードの呼び出しもとは、DeleteConfirm.php

delete-confirm.phpの以下のコードでDeleteConfirm.phpのhandleRequestメソッドが呼び出される。このDeleteConfirm.phpのhandleRequestメソッドがBoard.phpのdeletePostを呼び出す。Board.phpのdeletePostを呼び出す時に、($_SESSION['id']);を引数として、($post_id)に渡す。
$this->db->deletePost($_SESSION['id']);

Board.phpのdeletePostがDatabase.php の deletePost メソッドを呼び出す。

    |
    v
[データベースから指定された投稿を削除 (deletePost())]
    |
    v
[終了]


1.	削除ボタンをクリック: ユーザーが board.php で削除ボタンをクリックするとdelete-confirm.php に post_id が送信されます。
2.	delete-confirm.php 内で処理: 送信された post_id は $_SESSION['id'] に保存されます。
3.	deletePost() メソッドの呼び出し: deletePost() メソッド内で $_SESSION['id'] が取得され、それが deletePost($post_id) に引数として渡されます。
4.	Database.php 内の処理: 最終的に Database.php 内の deletePost($post_id) が呼び出され、指定された投稿が削除されます。

-------------------------------------------------------------------

[getPostById()メソッド]
    |
    v
[データベースから指定されたIDの投稿を取得 (getPostById())]
    |
    v
[取得した投稿データを返す]
    |
    v
[終了]

-------------------------------------------------------------------

[updatePost()メソッド]
    |
    v
[データベースの投稿データを更新 (updatePost())]
    |
    v
[終了]



<SessionManager.php フローチャート>
[セッション開始を確認 (startSession)]
    |
    v
[セッションが開始されているか確認 (session_status())]
    |
    +----> [セッションが開始されていない場合]
    |         |
    |         v
    |    [セッションの設定を変更 (ini_set)]
    |         |
    |    [セッションを開始 (session_start)]
    |         |
    |    [セッション有効期限の確認 (isSessionExpired)]
    |         |
    |         +----> [有効期限が切れている場合]
    |                    |
    |               [セッションを破棄 (session_unset, session_destroy)]
    |                    |
    |               [新しいセッションを開始 (session_start)]
    |                    |
    |               [セッションIDを再生成 (session_regenerate_id)]
    |
    v
[最終アクティビティ時間を更新 ($_SESSION['LAST_ACTIVITY'])]
    |
    v
[終了]

------------------------------------------------------

[セッションの有効期限を確認 (isSessionExpired)]
    |
    v
[最終アクティビティ時間が存在するか確認]
    |
    +----> [存在しない場合]
    |         |
    |         v
    |    [有効期限が切れていない (false)]
    |
    +----> [存在する場合]
              |
         [現在時刻 - 最終アクティビティ時間 > 1800秒か確認]
              |
         +----> [有効期限が切れている (true)]
         |         |
         |    [有効期限が切れていない (false)]
         |
         v
    [有効期限が切れている場合は true を返す]
    [有効期限が切れていない場合は false を返す]

------------------------------------------------------

[CSRFトークンを生成 (setToken)]
    |
    v
[ランダムなトークンを生成 (uniqid, sha1)]
    |
    v
[トークンをセッションに保存 ($_SESSION['board_token'])]
    |
    v
[トークンを返す (return $token)]

------------------------------------------------------

[CSRFトークンを検証 (validateToken)]
    |
    v
[セッションにトークンが存在するか確認 ($_SESSION['board_token'])]
    |
    +----> [トークンが存在しない、または一致しない場合]
    |         |
    |    [不正な投稿として処理を終了 (exit)]
    |
    v
[トークンをセッションから削除 (unset $_SESSION['board_token'])]
    |
    v
[フォームからトークンを削除 (unset $_POST['board_token'])]

------------------------------------------------------

[ユーザーがログインしているか確認 (isLoggedIn)]
    |
    v
[セッションに user_id が存在するか確認 ($_SESSION['user_id'])]
    |
    v
[存在する場合は true、存在しない場合は false を返す] 返した値はBoard.phpのconstruct()で使われる

------------------------------------------------------

[ユーザーをログイン状態に設定 (loginUser)]
    |
    v
[セッションに user_id を保存 ($_SESSION['user_id'] = $user_id)]

------------------------------------------------------

[ログアウト処理 (logoutUser)]
    |
    v
[セッションデータを削除 (session_unset)]
    |
    v
[セッションを破棄 (session_destroy)]


<DeleteConfirm.php フローチャート>
[開始]
    |
    v
[DeleteConfirmクラスのインスタンス作成]
    |
    v
[セッションの開始 (startSession())]
    |
    v
[POSTリクエストを処理 (handleRequest())]
    |
    v
[削除ボタンが押されたか？ (isset($_POST['delete_btn']))]
    |----> [はい] -----> [削除対象の投稿情報を取得 (getPostInfo())]
    |                          |
    |                          v
    |                  [POSTリクエストに投稿IDが含まれているか確認 (isset($_POST['post_id']) && $_POST['post_id'] != '')]
    |                          |
    |                          v
    |                  [投稿IDをセッションに保存 ($_SESSION['id'] = $_POST['post_id'])]
    |                          |
    |                          v
    |                  [データベース接続を取得 ($pdo = $this->db->getPdo())]
    |                          |
    |                          v
    |                  [投稿情報をデータベースから取得 (SELECT id, title, comment, image_path)]
    |                          |
    |                          v
    |                  [投稿情報をセッションに保存 ($_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path'])]
    |
    |----> [削除確定ボタンが押されたか？ (isset($_POST['delete_submit_btn']))]
    |                          |
    |                          v
    |                  [CSRFトークンを検証 (validateToken())]
    |                          |
    |                          v
    |                  [トークンが無効なら "不正な投稿です" を表示]
    |                          |
    |                          v
    |                  [投稿をデータベースから削除 ($this->db->deletePost($_SESSION['id']))]
    |                          |
    |                          v
    |                  [セッションから投稿情報を削除 (unset($_SESSION['id'], $_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path']))]
    |                          |
    |                          v
    |                  [削除成功ページにリダイレクト (header('Location: delete-success.php'))]
    |
    |----> [キャンセルボタンが押されたか？ (isset($_POST['cancel_btn']))]
                               |
                               v
                       [セッションから投稿情報を削除 (unset($_SESSION['id'], $_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path']))]
                               |
                               v
                       [掲示板ページにリダイレクト (header('Location: board.php'))]
    |
    v
[終了]

<SessionManagerクラスの概要>
SessionManagerクラスは、ユーザーセッションの管理を行うための機能を提供します。セッションとは、ウェブサイトでユーザーの状態を一時的に保存するための仕組みです。例えば、ログイン状態やフォームに入力したデータを保持するために使われます。

<startSession() メソッド>
public function startSession()
{
    // すでにセッションが開始されているか確認
    if (session_status() == PHP_SESSION_NONE) {
        ini_set('session.gc_maxlifetime', 1800);
        ini_set('session.gc_divisor', 1);
        session_start();

        // セッションの有効期限をチェックし、期限切れならセッションを破棄
        if ($this->isSessionExpired()) {
            session_unset();
            session_destroy();
            session_start(); // 新しいセッションを開始
        }

        session_regenerate_id(true);
    }

    // 最終アクティビティ時間を更新
    $_SESSION['LAST_ACTIVITY'] = time();
}

#セッションの開始:
 •session_status(): 現在のセッションの状態を取得します。PHP_SESSION_NONEはセッションがまだ開始されていないことを意味します。
 •ini_set('session.gc_maxlifetime', 1800): セッションが有効な最大時間を設定します。この例では1800秒（30分）です。
 •session_start(): 新しいセッションを開始します。
#セッションの有効期限確認:
 •isSessionExpired(): セッションが有効期限を超えているかを確認するメソッドです。有効期限を超えている場合、セッションを破棄し、新しいセッションを開始します。
#セッションIDの再生成:
 •session_regenerate_id(true): セッションIDを再生成します。これにより、セッション固定攻撃（session fixation）を防ぐことができます。
#最終アクティビティ時間の更新:
 •$_SESSION['LAST_ACTIVITY'] = time();: ユーザーが最後にアクティブだった時間をセッションに記録します。



<DeleteSuccess.php フローチャート>
開始
    |
    v
[SessionManagerインスタンス作成]
    |
    v
[セッション開始 (startSession())]
    |
    v
[掲示板ページへのリダイレクト (3秒後)]
    |
    v
終了

<UpdateEdit.php フローチャート>
[開始]
    |
    v
[セッション開始 (startSession())]
    |
    v
[POSTリクエストの処理 (handleRequest())]
    |
    +-------------------------------+
    |                               |
    v                               v
[更新ボタンが押されたか確認]   [キャンセルボタンが押されたか確認]
    |                               |
    |                               v
    |                     [更新処理をキャンセル (cancelUpdate())]
    |                               |
    v                               |
[投稿情報取得 (getPostInfo())]       |
    |                               |
    v                               |
[投稿情報をセッションに保存]          |
    |                               |
    v                               |
[更新処理 (updatePost())]            |
    |                               |
    +--> [トークンの検証 (validateToken())]
    |                               |
    +--> [入力の検証 (validateInputs())]
    |                               |
    +--> [エラーがないか確認 (isValid())]
    |                               |
    +--> [投稿内容を更新 (executeUpdate())]
    |                               |
    v                               |
[掲示板ページにリダイレクト (board.php)] <------------------+
    |
    v
[終了]











<User.php>
[Userクラスのインスタンス作成]
    |
    v
[Databaseクラスのインスタンス生成]
    |
    v
[SessionManagerクラスのインスタンス生成]
    |
    v
[セッションを開始 (startSession())]
    |
    v
[リクエストに基づいて処理を選択]
    |
    +---------------------------+
    |                           |
    v                           v
[ログイン処理 (login())]       [ログアウト処理 (logout())]
    |                           |
    v                           v
[ユーザー名でDBから情報取得]    [セッションを破棄してログアウト]
    |                           |
    v                           v
[パスワードが一致するか確認]   [リダイレクトなどの処理]
    |                           |
    +---------> [一致]          |
    |             |             |
    |             v             |
    |     [セッションにuser_id保存]
    |             |
    |             v
    +-> [ログイン成功 -> trueを返す]
    |
    +-> [ログイン失敗 -> falseを返す]

    |
    v
[新規ユーザー登録 (register())]
    |
    v
[パスワードをハッシュ化]
    |
    v
[ユーザー名とハッシュ化パスワードをDBに保存]