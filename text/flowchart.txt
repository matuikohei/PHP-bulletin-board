<board.php>
セッション管理の開始
- `SessionManager->startSession()`
↓
ログイン状態の確認
- `SessionManager->isLoggedIn()`
    - ログインしていない場合:
        - `header('Location: login.php');` へリダイレクト
        - `exit();` で処理終了
↓
ページ番号の取得
- `$_GET['page']` を使用
↓
表示件数（limit）の設定
↓
検索キーワードの取得
- `$_GET['keyword']` を使用
↓
Board クラスのインスタンス作成
- `new Board()`
↓
ユーザーの投稿リクエストを処理
- `Board->handlePostRequest()`
↓
検索キーワードの有無による処理の分岐
- 検索キーワードがある場合:
    - `Board->searchPosts($keyword, $page, $limit)` で投稿の検索結果を取得
    - `Board->countSearchResults($keyword)` で検索結果の総投稿数を取得
- 検索キーワードがない場合:
    - `Board->getPosts($page, $limit)` で指定ページの投稿一覧を取得
    - `Board->getTotalPostCount()` で総投稿数を取得
↓
CSRFトークンの生成
- `Board->generateToken()`
↓
ログインしたユーザーのIDを取得
- `$_SESSION['user_id']` を使用
↓
総投稿数をもとに総ページ数を計算
- `ceil($total_posts / $limit)` を使用
↓
HTMLの生成と表示
- 投稿フォーム
- 検索フォーム
- 投稿リスト
- ページ






<Board.phpフローチャート>
<construct>
public function __construct()
    {
        // セッション管理クラスとデータベースクラスのインスタンスを作成
        $this->sessionManager = new SessionManager();
        $this->db = new Database();

        // セッションを開始
        $this->sessionManager->startSession();

        // ユーザーがログインしているか確認し、ログインしていない場合はログインページにリダイレクト
        if (!$this->sessionManager->isLoggedIn()) {
            header('Location: login.php'); // ログインしていない場合はログインページにリダイレクト
            exit();
        }
    }

#public function __construct()
	•説明: クラスがインスタンス化される（新しいオブジェクトが作られる）ときに、このメソッドが自動的に実行されます。

#$this->sessionManager = new SessionManager();
	-説明:
	    •$this->sessionManager は、このクラス内で sessionManager というプロパティ（クラス内の変数）を指します。$this は、現在のオブジェクト自身を指すキーワードです。
	    •new SessionManager() は、SessionManager クラスの新しいインスタンス（オブジェクト）を作成します。このオブジェクトは、セッション管理のための機能を提供します。
	    •この行は、SessionManager クラスのオブジェクトを作成し、それをこのクラスの sessionManager プロパティに保存します。

#$this->db = new Database();
	-説明:
	    •$this->db は、db というプロパティを指します。
	    •new Database() は、Database クラスの新しいインスタンスを作成します。このクラスは、データベースとのやり取りを行うためのものです。
	    •この行は、Database クラスのオブジェクトを作成し、それをこのクラスの db プロパティに保存します。

#$this->sessionManager->startSession();
	-説明:
	    •sessionManager プロパティ（SessionManager クラスのオブジェクト）の startSession() メソッドを呼び出して、セッションを開始します。
	    •セッションとは、サーバーとユーザー間でやり取りされるデータを保持する仕組みです。これにより、例えばログイン状態やユーザーの設定などを維持することができます。

#if (!$this->sessionManager->isLoggedIn()) {
	-説明:
	    •if 文 は、条件が真（true）である場合にその中のコードを実行します。ここでは、! 演算子を使って、isLoggedIn() が偽（false）の場合の処理を行います。
	    •! 演算子 は、「not」を意味します。つまり、!$this->sessionManager->isLoggedIn() は「ユーザーがログインしていない」という意味になります。

#isLoggedInメソッドでtrueが返されるケース
    •$_SESSION['user_id'] がセットされている場合。つまり、ユーザーがログインしているとき。

#isLoggedInメソッドでfalse が返されるケース
    •$_SESSION['user_id'] がセットされていない場合。つまり、ユーザーがログインしていない、またはログアウトしたとき。

#header('Location: login.php');
    •header() 関数 は、PHPでHTTPヘッダを送信するための関数であり、これによりブラウザに特定の指示を送ることができます。
	•リダイレクト とは、ユーザーを自動的に別のページに移動させる操作のことです。このコードでは、ユーザーを login.php ページに移動させます。
	•使用上の注意: header() 関数は、他のコンテンツがブラウザに送信される前に使う必要があります。

#header() 関数
    -header() 関数の詳細説明
	    •header() 関数とは何か？
	    •header() 関数は、PHPでHTTPヘッダを送信するために使う関数です。HTTPヘッダは、WebサーバーとWebブラウザ（ユーザーが使っているブラウザ）間でやり取りされる特別な情報です。この情報には、ブラウザがどう振る舞うべきか、どのようなデータが送信されるか、などが含まれています。
	    •HTTPヘッダって何？
	    •HTTPヘッダは、Webページのデータそのものではなく、Webページをどのように処理するかについての情報を含んでいます。たとえば、あるページが別のページにリダイレクト（転送）されるべきかどうか、あるいはそのページがキャッシュされるべきかどうかなどの指示が含まれています。

	-リダイレクトの意味:
	    •リダイレクトとは、ユーザーが現在見ているページから自動的に別のページに移動させる処理のことです。例えば、ユーザーがログインしていない状態で特定のページにアクセスしようとした場合、そのままアクセスを許すのではなく、まずログインページに移動させる、というような使い方をします。

    -header('Location: login.php'); の具体的な動作:
	    •このコードは、PHPが「Location: login.php」という指示をHTTPヘッダとしてブラウザに送信するものです。この指示を受け取ったブラウザは、即座に現在のページから login.php ページへと移動します。


#header() 関数の重要性
	-順序に注意:
	    •header() 関数は、ページの内容が出力される前に使わなければなりません。これは、HTTPヘッダはページのコンテンツ（HTMLやテキストなど）よりも先に送信される必要があるからです。もし何かを出力した後に header() を使おうとすると、エラーが発生します。
	-リダイレクトの柔軟性:
	    •header('Location: somepage.php'); と書けば、どんなページにでもユーザーをリダイレクトできます。これにより、ユーザーの操作や状況に応じて、適切なページに自動的に移動させることができます。

#exit();
	•説明:
	•exit() 関数は、スクリプトの実行を即座に終了します。これにより、header() でリダイレクトした後の処理が行われないようにします。

#constructコードの流れ
	1.クラスが作成されると、__construct() メソッドが自動的に呼び出される。
	2.SessionManager クラスと Database クラスのオブジェクトが作成され、それぞれのプロパティに保存される。
	3.セッションが開始される。
	4.ユーザーがログインしているか確認され、ログインしていない場合はログインページにリダイレクトされる。
    このように、コードはまず初期設定を行い、ユーザーがログインしていなければログインページに移動させる仕組みになっています。


<handlePostRequestメソッド>
public function handlePostRequest()
    {
        // フォームが送信されたか確認
        if ($_SERVER['REQUEST_METHOD'] === 'POST') {
            // CSRFトークンの検証
            $this->sessionManager->validateToken($_POST['board_token']);
            unset($_SESSION['id']);

            // タイトルが入力されているか確認
            if (isset($_POST['post_title']) && $_POST['post_title'] != '') {
                $_SESSION['title'] = $_POST['post_title'];
            } else {
                unset($_SESSION['title']);
                $this->err_msg_title = '※タイトルを入力して下さい';
            }

            // コメントが入力されているか確認
            if (isset($_POST['post_comment']) && $_POST['post_comment'] != '') {
                $_SESSION['comment'] = $_POST['post_comment'];
            } else {
                unset($_SESSION['comment']);
                $this->err_msg_comment = '※投稿内容を入力して下さい';
            }

            // 画像のアップロード処理
            $imagePath = $this->handleImageUpload();

            // タイトル、コメントが入力されており、画像アップロードに成功していれば投稿をデータベースに保存
            // DeleteConfig.phpでuser_idを使用するので削除しない
            if ($_SESSION['title'] != '' && $_SESSION['comment'] != '' && $imagePath !== false) {
                $title = $_SESSION['title'];
                $comment = $_SESSION['comment'];
                $userId = $_SESSION['user_id'];  // ログインユーザーIDを取得
                $this->db->insertPost($title, $comment, $userId, $imagePath);
                unset($_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path']);
            }
        }
    }

#メソッドの概要
このメソッドは、フォームから送信されたPOSTリクエストを処理し、ユーザーが入力したタイトル、コメント、画像を検証した後、すべてが適切であればそれをデータベースに保存します。また、必要に応じてエラーメッセージを設定し、入力が不十分な場合に適切な処理を提供します。


#public function handlePostRequest()
	•説明:
	    •public function handlePostRequest() は、クラスの中で定義された関数（メソッド）です。この関数は、外部から呼び出せる公開メソッドであり、投稿リクエストを処理する役割を持っています。
	    •handlePostRequest() は、リクエストがPOSTメソッドで送信されたかどうか、入力されたデータが適切かどうかを確認し、最終的にデータベースに保存するまでの一連の処理を担当します。


#if ($_SERVER['REQUEST_METHOD'] === 'POST') {
	•$_SERVER['REQUEST_METHOD'] とは？
	    •$_SERVER['REQUEST_METHOD'] は、現在のリクエスト（ブラウザからサーバーに送られた要求）がどの「HTTPメソッド」を使って行われたかを示します。
	    •HTTPメソッドとは、ウェブブラウザがサーバーに何をしたいかを伝える方法です。最も一般的なメソッドは GET と POST です。
	•GET メソッドとは？
	    •GET メソッドは、ユーザーがブラウザのURLバーにアドレスを入力したり、リンクをクリックしたときに使われます。データをサーバーに送信するのではなく、サーバーからデータを「取得」するために使われます。例えば、ウェブページの表示などです。
	    •GET リクエストのデータはURLに含まれるため、誰でも見える形式で送信されます。
	•POST メソッドとは？
	    •POST メソッドは、ユーザーがフォームにデータを入力して送信ボタンを押したときに使われます。データはリクエストの本文に含まれ、URLには表示されません。
	    •例えば、ログインフォームやコメントの送信など、データをサーバーに「送信」する場面で使われます。
	•なぜ $_SERVER['REQUEST_METHOD'] が重要か？
	    •この変数を使うことで、サーバー側のプログラムは、リクエストがどの方法で行われたかを知ることができます。これにより、例えばフォームが送信されたときだけ特定の処理を行ったり、ページを表示するだけのときに別の処理を行ったりすることができます。


    #if 文の詳細な説明
        •このコードの if 文の動作
            •if ($_SERVER['REQUEST_METHOD'] === 'POST') { という条件は、リクエストが POST メソッドで行われた場合のみ、以下のコードを実行することを意味しています。


    #具体的なコードの意味
        •	$_SERVER['REQUEST_METHOD'] === 'POST':
        •	ここで、$_SERVER['REQUEST_METHOD'] の値が 'POST' と等しい（===）かどうかを確認しています。=== は、値と型の両方が一致しているかをチェックする厳密な比較演算子です。
        •	もし $_SERVER['REQUEST_METHOD'] が 'POST' であれば、この if 文の条件は true となり、そのブロック内のコードが実行されます。
        •	フォーム送信時の処理
        •	このコードは、フォームがユーザーによって送信された場合に、その送信内容をサーバー側で処理するための準備を行っています。例えば、ログイン情報やユーザーが入力したデータをサーバーに送信して処理する場面です。


#$this->sessionManager->validateToken($_POST['board_token']);
	•validateToken($_POST['board_token']):
	•validateToken は、セッション管理クラスのメソッドで、フォームから送信されたCSRFトークンが正しいかどうかを確認するためのものです。
	•$_POST['board_token'] は、ユーザーがフォームを送信したときに一緒に送られるトークンの値です。このトークンは、サーバー側で生成され、フォームに隠しフィールドとして埋め込まれます。
	•動作: このコードは、フォームに含まれている board_token の値がサーバー側で保持しているトークンと一致するかを検証します。一致していれば、そのリクエストは正当なものであると判断され、次の処理に進むことができます。

    #どのタイミングでトークンが生成されるのか？
        board.phpのページに訪れた瞬間にトークンを生成。SessionManager.phpのgenerateTokenメソッドでトークンが生成される。このトークンをBoard.phpでも使えるのはセッションを使っているので、異なるスクリプト(SessionManager.phpやBoard.phpなどのPHPプログラム)で共有されるため

#unset($_SESSION['id']);
	•unset() 関数: これは、変数を削除するPHPの関数です。ここでは、セッション変数 $_SESSION['id'] を削除しています。
	•$_SESSION: これは、サーバー側でユーザーごとの情報を一時的に保存するための特別な変数です。セッションは、ユーザーがウェブサイトを利用している間、例えばログイン状態やカートの中身などの情報を保持するために使われます。
	•動作: $_SESSION['id'] というセッション変数に格納されていたデータを削除します。これにより、この変数はもう存在しなくなり、次にこのセッション変数にアクセスしようとすると、値が存在しない状態になります。

    #そもそもどこで$_SESSION['id']は生成されているの？
        •DeleteConfirm.php の getPostInfo() メソッドで、$_SESSION['id'] が作成されます。このIDは、削除対象の投稿IDを一時的に保存するために使用されます。
        •その後、削除の処理や確認を行うために、このIDが使われます。
        •Board.php の handlePostRequest() メソッドで、CSRFトークンが検証された後に unset($_SESSION['id']); が呼び出されます。これにより、削除や投稿処理が終わった後、セッションから $_SESSION['id'] が削除されます。

    #$_SESSION['id']と$_SESSION['user_id']の役割の違いは？
        -$_SESSION['user_id'] の役割:
            •役割:
            $_SESSION['user_id'] は、ログインしているユーザーを一意に識別するためのものです。この変数は、セッション全体を通じて保持され、ユーザーがログインしている間ずっと使われます。
            •使用タイミング:
            ユーザーがログインしているかどうかを確認する際や、ユーザーに関連する操作（例えば、投稿や削除など）を行う際に利用されます。
        -$_SESSION['id'] の役割:
            •役割:
            $_SESSION['id'] は、特定の投稿や操作に関連する一時的なIDを保持するために使用されます。例えば、削除対象の投稿IDを保持するためです。
            •使用タイミング:
            投稿の削除や編集など、特定の操作が完了したら削除される一時的なデータとして使われます。

#if ($_SESSION['title'] != '' && $_SESSION['comment'] != '' && $imagePath !== false) {
    #$imagePath !== falseを$imagePath == trueに変更してはだめ？
        #結論
            •変更しない方が良い理由:
            •if ($imagePath !== false) は、$imagePath に false 以外の値が入っていることを確認する条件です。これは、画像のパスや true など、いろいろな値が許容されるため柔軟に動作します。
            •if ($imagePath === true) は、$imagePath が厳密に true である場合しか条件が満たされないため、意図しない動作を引き起こす可能性があります。特に、$imagePath にファイルパスが入っている場合、この条件では false になってしまい、画像が正常にアップロードされても処理が行われないことになります。
        #推奨
            •現在のコードを維持する: $imagePath !== false は、画像が正しくアップロードされたかどうかを確認するための適切な条件です。変更せずにそのまま使うのが安全です。

        #違いの説明
            1.$imagePath !== false:
                •この条件では、$imagePath が厳密に false ではない場合に true となります。これには true、null、0、""、"some/path" など、false 以外のすべての値が含まれます。
            2.$imagePath === true:
                •この条件では、$imagePath が厳密に true の場合のみ true となります。つまり、$imagePath が本当に true という値を持っているときだけ条件が満たされます。

        #具体例での違い
            •$imagePath が 'uploads/image.jpg'（ファイルパス）を持っている場合:
            •$imagePath !== false: true となり、条件が満たされます。
            •$imagePath === true: false となり、条件は満たされません。
            •$imagePath が true を持っている場合:
            •$imagePath !== false: true となります。
            •$imagePath === true: true となります。
            •$imagePath が false を持っている場合:
            •両方とも false となります。

#$title = $_SESSION['title'];
#$comment = $_SESSION['comment'];
#$userId = $_SESSION['user_id'];  // ログインユーザーIDを取得
#$this->db->insertPost($title, $comment, $userId, $imagePath);
    •Database.phpのinsertPostメソッドを使用し、データーベースに、タイトル、コメント、画像、ユーザーIDを保存

    #SESSIONにtitleやcommentの中にデータを入れてきたのに、最終的に変数、$title や $comment にデーターを入れた理由
        •PHPコードの中で、セッション変数から一時的なローカル変数にデータを移す理由は、処理の分かりやすさや効率性、セキュリティなどの複数の要因がある。
        •セッション変数はユーザーの入力データを保持するために使い、ローカル変数は特定の処理（ここではデータベースへの保存）を効率的に行うために使われる。

    #セッション変数とローカル変数の役割
        -セッション変数の役割
            •セッション変数 ($_SESSION['title'] や $_SESSION['comment']) は、ユーザーがページを移動してもデータを保持するために使わる。
            •ユーザーがフォームに入力したデータを保持し、エラーメッセージが表示された場合でも入力内容を再表示するために使われる。

        -ローカル変数の役割
            •ローカル変数 ($title や $comment) は、データベースに保存する際や、一時的にデータを処理するために使われる。
            •データベース操作や他の処理では、セッション変数を直接操作するよりも、ローカル変数を使った方がコードがシンプルで分かりやすくなる。


    #セッションのデータを直接、データベースに保存せずに、一度、変数に代入してから保存する理由>
        -理由1: コードの読みやすさ・理解しやすさ
            プログラムを読んだり書いたりするとき、変数名はとても大切です。変数名がわかりやすいと、プログラムの意図や動きを理解しやすくなります。
            たとえば、$_SESSION['title'] は、セッションの中に保存されたタイトルですが、毎回 $_SESSION['title'] と書くと、何をしているのか直感的にわかりにくくなります。これを $title という変数に代入することで、タイトルを扱っているんだなとすぐにわかるようになります。

        -理由2: コードの保守性
            もし、後で $_SESSION['title'] を他のデータから取得するように変更したい場合、一度変数に代入しておくことで、変更が必要な箇所が減ります。
            たとえば、$title という変数に代入した後に使っていれば、変数に代入する部分だけを修正すればよいですが、もし $_SESSION['title'] を直接使っていると、そのコードが複数箇所にある場合、すべて修正しなければなりません。

        -理由3: 可読性の向上と誤りの防止
            長いコードや複雑な処理で $_SESSION['title'] などを何度も書くと、タイプミスが起きやすくなります。変数に代入しておけば、タイプミスのリスクが減り、コードがすっきりして読みやすくなります。

        -まとめ
            このように、一度変数に代入することで、コードが読みやすくなり、後で修正しやすくなり、ミスが減りやすくなるという利点があります。プログラムを簡潔かつ明確に保つための、良い習慣の一つです。


#unset($_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path']);
    •保存が完了した後、unset($_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path']); でこれらのセッション変数を削除。user_id は後の処理で使用するため、削除しない。




<handleImageUploadメソッド>
  private function handleImageUpload()
    {
        // フォームで画像がアップロードされているか確認し、アップロードにエラーがないか確認
        if (isset($_FILES['post_image']) && $_FILES['post_image']['error'] == UPLOAD_ERR_OK) {

            $uploadDir = 'uploads/';
            $uploadFile = $uploadDir . basename($_FILES['post_image']['name']);

            if (move_uploaded_file($_FILES['post_image']['tmp_name'], $uploadFile)) {
                return $uploadFile;
            } else {
                $this->err_msg_image = '画像のアップロードに失敗しました';
                return false;
            }
        }
        return '';
    }

#メソッドの概要
このメソッドは、ユーザーがフォームから画像をアップロードしたときに、その画像をサーバーに保存するための処理を行っています。画像が正常にアップロードされれば、ファイルの保存場所を返し、失敗した場合にはエラーメッセージを設定して false を返します。

#if (isset($_FILES['post_image']) && $_FILES['post_image']['error'] == UPLOAD_ERR_OK) {
    -コードの概要
        •isset($_FILES['post_image']) は、ユーザーが画像をアップロードしているかどうかを確認します。
	    •$_FILES['post_image']['error'] == UPLOAD_ERR_OK は、アップロードされた画像にエラーがないかを確認します。
	    •&& 演算子 は、これらの条件が両方とも true であることを確認します。

	#isset($_FILES['post_image']) の意味
	    •isset() 関数:
	        •isset() は、変数が設定されており、かつ null ではないことを確認する関数です。
	        •ここでは、$_FILES['post_image'] という変数が存在しているかどうかを確認しています。
	    •$_FILES['post_image']:
	        •$_FILES は、ユーザーがフォームを通じてアップロードしたファイルの情報を格納するスーパーグローバル変数です。$_FILES['post_image'] は、フォームの name="post_image" というフィールドにアップロードされたファイルの情報を持っています。
        •この部分の意味:
	        •isset($_FILES['post_image']) は、ユーザーが画像をアップロードしたかどうかを確認しています。アップロードされている場合は、この条件が true になります。

    #フィールド（Field）とは？
        •フィールド（field） とは、HTMLフォームの中でユーザーがデータを入力したり選択したりするための要素を指します。これには、テキストボックス、チェックボックス、ラジオボタン、ファイルアップロードボタンなどが含まれます。フィールドは、ユーザーが入力したデータをサーバーに送信するための情報を保持します。
            •コード例
                <label for="post_image">Upload Image:</label>
                <input type="file" id="post_image" name="post_image">
            •説明:
	            •このフィールドは、ユーザーがファイル（画像など）をアップロードするためのものです。
	            •name="post_image" という属性が付いているため、アップロードされたファイルの情報は $_FILES['post_image'] でサーバー側に送信されます。
            •フィールドと $_FILES の関係
                •$_FILES['post_image'] について:
	                •$_FILES['post_image'] は、フォームの <input type="file" name="post_image"> フィールドを指します。
	                •これは、ユーザーが画像などのファイルを選択してアップロードするときに、そのファイルに関する情報（ファイル名、ファイルの一時的な保存場所、エラーステータスなど）が格納される場所です。
	        •name 属性:
	            •フィールドには通常 name 属性が設定されており、これによってサーバーに送信されるデータが識別されます。例えば、name="post_image" と設定されていれば、アップロードされたファイルの情報は $_FILES['post_image'] に格納されます。

    -$_FILES['post_image']['error'] == UPLOAD_ERR_OK の意味
	    •$_FILES['post_image']['error']:
	        •これは、アップロードされたファイルに関するエラーコードが格納されている部分です。エラーがない場合、UPLOAD_ERR_OK という定数が設定されます。
	    •UPLOAD_ERR_OK:
	        •UPLOAD_ERR_OK はファイルが正常にアップロードされたことを意味します。
	    •この部分の意味:
	        •$_FILES['post_image']['error'] == UPLOAD_ERR_OK は、アップロードされたファイルにエラーが発生していないかどうかを確認しています。エラーがない場合、この条件が true になります。

#$uploadDir = 'uploads/';
    #説明:
        •$uploadDir は、変数の名前です。変数とは、データを一時的に保存しておくための「箱」のようなものです。この「箱」にデータを入れておくことで、後でそのデータを簡単に使うことができます。
        •'uploads/' は、この変数に保存されるデータ（文字列）です。具体的には、アップロードされたファイルを保存するディレクトリのパスを示しています。
    #この行の意味:
        'uploads/' というディレクトリを保存するために $uploadDir という変数を使っています。アップロードされたファイルは、このディレクトリに保存される予定です。

#$uploadFile = $uploadDir . basename($_FILES['post_image']['name']);
	•$uploadFile は、ファイルが最終的に保存される場所（ディレクトリとファイル名）を保持する変数です。
	•$uploadDir . basename($_FILES['post_image']['name']):
	    •$uploadDir . は、ディレクトリのパスとファイル名を結合するために使われています。. はPHPで文字列を結合するための演算子です。例えば、'uploads/' . 'example.jpg' とすると、'uploads/example.jpg' という結果が得られます。
	•basename($_FILES['post_image']['name']):
	    •basename() 関数: この関数は、ファイルのフルパスからファイル名だけを取り出す関数です。ここでは、$_FILES['post_image']['name'] からファイル名だけを取り出しています。
	    •$_FILES['post_image']['name']: これは、ユーザーがアップロードしたファイルの元の名前を指します。例えば、ユーザーが myphoto.jpg というファイルをアップロードした場合、この値には 'myphoto.jpg' が含まれます。
    •この行の意味:
	    •basename($_FILES['post_image']['name']) でファイル名を取得し、それを $uploadDir（'uploads/'）と結合して、ファイルが保存されるフルパス（例えば、'uploads/myphoto.jpg'）を作成しています。
	    •これにより、アップロードされたファイルが 'uploads/' ディレクトリの中に元のファイル名で保存されるようにしています。

#if (move_uploaded_file($_FILES['post_image']['tmp_name'], $uploadFile)) {
	#move_uploaded_file() 関数の説明
        •move_uploaded_file() 関数:
            •これは、PHPで提供されている関数で、ユーザーがアップロードしたファイルを一時的な場所から、指定された最終保存場所に移動するために使われます。
            •一時的な保存場所は、サーバーがアップロードされたファイルを短期間保存するためのディレクトリで、通常はOSの設定によって決まる場所（例: /tmp や C:\Windows\Temp）です。
            •この関数は、ファイルが正常に移動できた場合に true を返し、何らかの理由で失敗した場合に false を返します。
        •move_uploaded_file() の引数:
            •第一引数 ($_FILES['post_image']['tmp_name']):
                •$_FILES['post_image']['tmp_name'] は、ユーザーがアップロードしたファイルがサーバー上に一時的に保存されている場所を指します。
                •ファイルがアップロードされると、サーバーはそのファイルを一時フォルダに保存します。この一時フォルダのパスが tmp_name に格納されています。
            •第二引数 ($uploadFile):
                •$uploadFile は、ファイルが最終的に移動される場所を指定する変数です。通常は、ユーザーがアップロードしたファイルの保存先ディレクトリとファイル名を含む完全なパスが指定されます。

#return $uploadFile; と return false;
	•return $uploadFile;:
	    •画像が正常にアップロードされた場合、ファイルの保存場所（パス）を返します。
        •この返された画像のパスは、データーベースへ画像を保存する時に使います。
	•return false;:
	    •画像のアップロードが失敗した場合、このメソッドは false を返します。これにより、呼び出し元のコードでアップロードが失敗したことを確認でき、適切なエラーメッセージを表示するなどの処理が行えます。

#$this->err_msg_image = '画像のアップロードに失敗しました';
	•$this->err_msg_image:
	    •これは、クラスのプロパティです。$this は現在のオブジェクトを指し、そのオブジェクトの err_msg_image プロパティにアクセスしています。
	•'画像のアップロードに失敗しました':
	    •これは、文字列であり、エラーメッセージの内容を表しています。画像のアップロードが失敗したときに、ユーザーに伝えるためのメッセージです。
	•この行の意味:
	    •画像のアップロードに失敗したときに、err_msg_image プロパティに「画像のアップロードに失敗しました」というエラーメッセージを設定しています。これにより、後でこのエラーメッセージを表示することができます。

#return false;
	•return 文:
	    •これは、関数やメソッドの実行を終了し、呼び出し元に値を返すために使われる構文です。
	    •ここでは、false を返して、このメソッドの実行を終了しています。
	•false:
	    •false は、ブール型の値で、「偽」を意味します。この場合、画像のアップロードが成功しなかったことを示しています。
	•この行の意味:
	    •画像のアップロードが失敗したときに、このメソッドは false を返します。これにより、呼び出し元のコードはアップロードが失敗したことを確認できます。
        •false を返すことで、このメソッドが失敗したことを呼び出し元に伝えます。呼び出し元は、この false を受け取って、例えばエラーメッセージを表示したり、再度アップロードを促すなどの処理を行うことができます。

#return '';
	•無処理を示す:
	•この return ''; は、呼び出し元に「画像のアップロードが行われなかった」ことを知らせるためのシンプルな方法です。
	•空の文字列を返すことで、呼び出し元は、アップロードが実行されなかったことを理解し、その後の処理をスキップしたり、別の処理を行ったりすることができます。















<Board.php フローチャート>
[開始]
    |
    v
[Boardクラスのインスタンス作成]
board.phpでインスタンスを作成する
    |
    v
[__construct()メソッド呼び出し]
board.phpでインスタンスが生成されると自動でconstructが呼び出される
    |
    v
[SessionManagerインスタンス作成] ---> [セッション開始 (startSession())]
セッションは、サーバー側でユーザーごとのデータを一時的に保持するため箱
    |
    v
[Databaseインスタンス作成]
    |
    v
[ログイン状態を確認 isLoggedIn()メソッドの呼び出し]
isLoggedInメソッドは、SessionManager.phpにある
    |
    v
[ログイン済みか？] --------> [未ログイン] -------> [ログインページにリダイレクト] ---> [終了]
if (!$this->sessionManager->isLoggedIn()) は、isLoggedIn メソッドを使ってユーザーがログインしているかどうかを確認。! は否定演算子で、isLoggedIn() が false を返す（ログインしていない）場合に if 文の内部が実行。
header('Location: login.php'); は、ユーザーがログインしていない場合に、ブラウザを login.php ページにリダイレクトする。
exit(); は、スクリプトの実行をここで終了させる。これにより、未ログインのユーザーが続行することを防ぐ。
    |
    v
[ログイン済み]
    |
    v
[handlePostRequest()メソッド呼び出し]
    |
    v
[POSTリクエストか？（投稿ボタンが押されたか）] --------> [POSTリクエストでない] ---> [終了]
    |
    v
[POSTリクエスト]
if ($_SERVER['REQUEST_METHOD'] === 'POST')
$_SERVERという箱の中に入っている、['REQUEST_METHOD']という情報が、POSTであるか確認している。
    |
    v
[CSRFトークンを検証 (validateToken())]


$_POSTという箱の中に入っている、['board_token']という情報。
$_POST['board_token'] は、フォーム送信時に送られてきたトークンのこと。SessionManager.phpのvalidateToken メソッド（工場）に、$_POST['board_token']という材料を渡して、そのトークンが正しいかどうかを確認している

SessionManager.phpのvalidateToken メソッドでは、トークンが正しければ、何も返さずに、違った場合のみ処理を中止させる。
    |
    v
[タイトルが入力されているか？]
    |
    v
[タイトルあり] --------> [タイトルなし] ---> [タイトルのエラーメッセージを設定] ---> [終了]
    |
    v
[コメントが入力されているか？]
    |
    v
[コメントあり] --------> [コメントなし] ---> [コメントのエラーメッセージを設定] ---> [終了]
    |
    v
[画像アップロード処理 (handleImageUpload())]
    |
    v
[タイトル、コメント、画像アップロードが成功しているか？]
    |
    v
[成功している] --------> [失敗している] ---> [終了]
    |
    v
[データベースに投稿を保存 (insertPost())]
if ($_SESSION['title'] != '' && $_SESSION['comment'] != '' && $imagePath !== false) {
    $title = $_SESSION['title'];
    $comment = $_SESSION['comment'];
    $userId = $_SESSION['user_id'];  // ログインユーザーIDを取得
    $this->db->insertPost($title, $comment, $userId, $imagePath);
    unset($_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path']);
}
Database.phpのinsertPostメソッドを使用し、データーベースに、タイトル、コメント、画像、ユーザーIDを保存
    |
    v
[セッションのタイトルとコメント、イメージを削除]
保存が完了した後、unset($_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path']); でこれらのセッション変数を削除。user_id は後の処理で使用するため、削除しない。
    |
    v
[終了]

-------------------------------------------------------------------
[handleImageUpload()メソッド]
private function handleImageUpload() {
        // フォームで画像がアップロードされているか確認し、アップロードにエラーがないか確認
        if (isset($_FILES['post_image']) && $_FILES['post_image']['error'] == UPLOAD_ERR_OK) {
            // アップロードされた画像を保存するディレクトリを指定
            $uploadDir = 'uploads/';
            // 保存先のファイルパスを生成（ディレクトリ + ファイル名）
            $uploadFile = $uploadDir . basename($_FILES['post_image']['name']);

            // アップロードされた画像ファイルを指定したディレクトリに移動
            if (move_uploaded_file($_FILES['post_image']['tmp_name'], $uploadFile)) {
                // 移動に成功した場合、保存先のファイルパスを返す
                return $uploadFile;
            } else {
                // 画像の移動に失敗した場合、エラーメッセージを設定し、falseを返す
                $this->err_msg_image = '画像のアップロードに失敗しました';
                return false;
            }
        }
        return '';
}
    |
    v
[画像がアップロードされたか？]
if (isset($_FILES['post_image']) && $_FILES['post_image']['error'] == UPLOAD_ERR_OK)
$_FILES という箱の中に 'post_image' という名前の情報が入っているかどうかを確認している。
これは、ユーザーが画像ファイルをアップロードしようとした場合、その情報が $_FILES に保存されるため、アップロードが行われたかどうかをチェックするために使われる。

$_FILES['post_image']['error'] == UPLOAD_ERR_OKについて
ユーザーがアップロードした画像ファイルに関するさまざまな情報が $_FILES['post_image'] の中に入っている。

この情報の中には、例えば以下のようなものがある。
'name': ファイルの元の名前
'type': ファイルのタイプ（例えば “image/jpeg” など）
'size': ファイルのサイズ（バイト数）
'tmp_name': サーバーに一時的に保存されたファイルのパス
'error': アップロード中に発生したエラーコード

'error' とは？
'error' は、ファイルのアップロード時に問題が発生したかどうかを示す値。具体的には、アップロードの成功・失敗を表すコードが入ってる。

UPLOAD_ERR_OK とは？
UPLOAD_ERR_OK は、アップロードが成功したことを示す特別な定数（一定の値）。PHP では、アップロードが正常に行われた場合、この 'error' キーには UPLOAD_ERR_OK という値がセットされる。

$_FILES['post_image']の['error']の中にUPLOAD_ERR_OKという情報が入っているかどうかを確認することで、画像が問題なくアップロードされたかを確認している

    |
    v
[アップロード成功] --------> [アップロード失敗またはなし] ---> [エラーメッセージを設定しfalseを返す] ---> [終了]
    |
    v
[画像を指定のディレクトリに保存]
$uploadDir = 'uploads/';
$uploadFile = $uploadDir . basename($_FILES['post_image']['name']);
    |
    v
[画像のパスを返す]
return $uploadFile
この行は、「アップロードしたファイルの保存場所」を返す
$uploadFileという箱に、保存されたファイルのパス（場所）が入っている。
例えば、“uploads/example.jpg” というパスが返されると、その後の処理でそのファイルの場所を使って、画像を表示したり、データベースに保存したりすることができる。

具体的には、handleImageUpload()メソッドで取得した画像のパスは、Board.phpのhandlePostRequestの＄imagePathという箱の中に保存される。
    |
    v
[終了]

-------------------------------------------------------------------

[getPosts()メソッド]
//  指定されたページの投稿を取得するメソッド
public function getPosts($page = 1, $limit = 10) {
    return $this->db->fetchPostsByPage($page, $limit);
}
    |
    v
[データベースから指定されたページの投稿を取得 (fetchPostsByPage())]
getPosts($page, $limit) が呼び出されると、その中で Databese.phpのfetchPostsByPage($page, $limit) が実行
fetchPostsByPage メソッドは、データベースから指定されたページと表示件数に基づいて投稿データを取得
    |
    v
[取得した投稿を返す]
返す先は、呼び出し元の、board.phpの$post_listに格納
$post_list = $board->getPosts($page, $limit);
$post_list にはデータベースから取得された投稿データが格納され、これが掲示板に表示される投稿リストとして使われる
    |
    v
[終了]

-------------------------------------------------------------------

[getTotalPostCount()メソッド]
$total_posts = $board->getTotalPostCount();
board.phpで呼び出される。呼び出されて実行された値は、board.phpの$total_postsに格納される
    |
    v
[データベースから投稿の総数を取得 (countAllPosts())]
Database.phpのcountAllPostsメソッドを呼び出す。処理の結果としてデータベースの board_info テーブル内の投稿数をカウントし、その数を返します
    |
    v
[取得した投稿の総数を返す]
    |
    v
[終了]

-------------------------------------------------------------------

[searchPosts()メソッド]
board.phpで呼び出される。
// 検索キーワードがある場合の処理と通常の投稿取得処理
if (!empty($keyword)) {
    // 検索キーワードがある場合の処理
    $post_list = $board->searchPosts($keyword, $page, $limit); // 検索結果を取得
    $total_posts = $board->countSearchResults($keyword); // 検索結果の総投稿数を取得
} else {
    // 通常の投稿取得処理
    $post_list = $board->getPosts($page, $limit); // 指定されたページの投稿一覧を取得
    $total_posts = $board->getTotalPostCount(); // 総投稿数を取得
}
    |
    v
[データベースから指定されたキーワードで投稿を検索 (searchPosts())]
public function searchPosts($keyword, $page = 1, $limit = 10) {
    return $this->db->searchPosts($keyword, $page, $limit);
}
Database.phpのsearchPostsを呼び出す

引数になっている$keywordはboard.phpの以下の流れで渡される

検索フォームに文字が入力される。method="get"が使われているので、$_GETへ情報が送られる
<form action="board.php" method="get">
                <input type="text" name="keyword" placeholder="検索キーワードを入力">
                <button type="submit" name="search_button">検索</button>
                <?php if (!empty($keyword)): ?>
                    <a href="board.php">全て表示</a>
                <?php endif; ?>
            </form>

送られてきた情報を$keywordに格納
$keyword = isset($_GET['keyword']) ? $_GET['keyword'] : '';

検索結果を持ってくるために作られたsearchPostsを使って、($keyword, $page, $limit)をもとに検索結果を持ってきて、
検索結果を格納するための$post_listという箱に格納される
$post_list = $board->searchPosts($keyword, $page, $limit);
    |
    v
[取得した検索結果を返す]
    |
    v
[終了]

-------------------------------------------------------------------

[countSearchResults()メソッド]
public function searchPosts($keyword, $page = 1, $limit = 10) {
        return $this->db->searchPosts($keyword, $page, $limit);
}
    |
    v
[データベースから検索結果の投稿総数を取得 (countSearchResults())]
    |
    v
[取得した検索結果の総数を返す]
このメソッドは、board.phpで呼び出されて、結果は、$total_postsに格納される
if (!empty($keyword)) {
    // 検索キーワードがある場合の処理
    $post_list = $board->searchPosts($keyword, $page, $limit); // 検索結果を取得
    $total_posts = $board->countSearchResults($keyword); // 検索結果の総投稿数を取得
} else {
    // 通常の投稿取得処理
    $post_list = $board->getPosts($page, $limit); // 指定されたページの投稿一覧を取得
    $total_posts = $board->getTotalPostCount(); // 総投稿数を取得
}
    |
    v
[終了]

-------------------------------------------------------------------

[generateToken()メソッド]
    |
    v
[セッションマネージャーを使ってCSRFトークンを生成 (setToken())]
SessionManager.phpのsetTokenを呼び出す。
    |
    v
[生成されたトークンを返す]
board.phpの$tokenへトークンを返す
$token = $board->generateToken(); // CSRFトークンを生成
    |
    v
[終了]

-------------------------------------------------------------------

[getErrMsgTitle()メソッド]
public function getErrMsgTitle() {
    return $this->err_msg_title;
}

タイトル欄がからの場合は、Board.phpの
if (isset($_POST['post_title']) && $_POST['post_title'] != '') {
    $_SESSION['title'] = $_POST['post_title'];
    } else {
    unset($_SESSION['title']);
    $this->err_msg_title = '※タイトルを入力して下さい';
}
このコードの処理によって、private $err_msg_title = '';にタイトルを入力して下さいと格納して結果を返す。
タイトルが記載されている場合は、private $err_msg_title = '';を空の箱のまま返す。
    |
    v
[タイトルのエラーメッセージを返す]
このメソッドはboard.phpで呼び出される。
board.phpのコードでは、$err_msg_titleが空の場合は、何も処理をしないで、$err_msg_titleに文字が入力されている場合のみ処理を行う
<label>
    <p>タイトル（※最大30文字）</p>
    <input type="text" name="post_title" value="<?php if (isset($_SESSION['title'])) echo htmlspecialchars($_SESSION['title'], ENT_QUOTES, 'UTF-8'); ?>">
    <!-- タイトルのエラーメッセージ表示 -->
    <?php if (!empty($board->getErrMsgTitle())) {
        echo "<p class='err'>" . htmlspecialchars($board->getErrMsgTitle(), ENT_QUOTES, 'UTF-8') . "</p>";
    } ?>
</label>


    |
    v
[終了]

-------------------------------------------------------------------

[getErrMsgComment()メソッド]
上のタイトルのメソッドと流れは同じ
    |
    v
[コメントのエラーメッセージを返す]
    |
    v
[終了]

-------------------------------------------------------------------

[getErrMsgImage()メソッド]
基本的な流れは上と同じ。だけどエラーメッセージを作成するコードは、別の場所
    |
    v
[画像のエラーメッセージを返す]
    |
    v
[終了]

-------------------------------------------------------------------

[deletePost()メソッド]
public function deletePost($post_id) {
        $this->db->deletePost($post_id);
}

このコードの呼び出しもとは、DeleteConfirm.php

delete-confirm.phpの以下のコードでDeleteConfirm.phpのhandleRequestメソッドが呼び出される。このDeleteConfirm.phpのhandleRequestメソッドがBoard.phpのdeletePostを呼び出す。Board.phpのdeletePostを呼び出す時に、($_SESSION['id']);を引数として、($post_id)に渡す。
$this->db->deletePost($_SESSION['id']);

Board.phpのdeletePostがDatabase.php の deletePost メソッドを呼び出す。

    |
    v
[データベースから指定された投稿を削除 (deletePost())]
    |
    v
[終了]


1.	削除ボタンをクリック: ユーザーが board.php で削除ボタンをクリックするとdelete-confirm.php に post_id が送信されます。
2.	delete-confirm.php 内で処理: 送信された post_id は $_SESSION['id'] に保存されます。
3.	deletePost() メソッドの呼び出し: deletePost() メソッド内で $_SESSION['id'] が取得され、それが deletePost($post_id) に引数として渡されます。
4.	Database.php 内の処理: 最終的に Database.php 内の deletePost($post_id) が呼び出され、指定された投稿が削除されます。

-------------------------------------------------------------------

[getPostById()メソッド]
    |
    v
[データベースから指定されたIDの投稿を取得 (getPostById())]
    |
    v
[取得した投稿データを返す]
    |
    v
[終了]

-------------------------------------------------------------------

[updatePost()メソッド]
    |
    v
[データベースの投稿データを更新 (updatePost())]
    |
    v
[終了]































<Database.php フローチャート>
[Databaseクラスのインスタンス生成]
    |
    v
[ConfigクラスからDSN、ユーザー名、パスワードを取得]
$dsn = Config::DB_HOST;
$username = Config::DB_USER;
$password = Config::DB_PASSWORD;
    |
    v
[PDOオブジェクトの生成 (try-catch)]
public function __construct()
    {
        // DSNの設定をConfigクラスから読み込む
        $dsn = Config::DB_HOST;
        $username = Config::DB_USER;
        $password = Config::DB_PASSWORD;

        try {
            $this->pdo = new PDO($dsn, $username, $password, [
                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                PDO::ATTR_EMULATE_PREPARES => false,
            ]);
        } catch (PDOException $e) {
            // エラーメッセージを表示
            echo '接続失敗: ' . $e->getMessage();
            exit();
        }
    }

上記のコードで、Database.phpのpdoの中にPDOオブジェクトを格納している。

<tryブロック>
try {
    $this->pdo = new PDO($dsn, $username, $password, [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_EMULATE_PREPARES => false,
    ]);
}

#例え
あなたがホテルにチェックインしようとしているとします。チェックインカウンターに行って、部屋の予約確認をしますね。この部分が「tryブロック」に相当します。「試してみる」段階です。
#PDOインスタンスの作成
new PDO($dsn, $username, $password, [...]) は、データベースに接続するための新しい「鍵」を作る作業。鍵（PDOオブジェクト）を使ってデータベース（ホテルの部屋）にアクセスできるようにする。
#オプション設定
・PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION: これは、「部屋がない」とか「予約が見つからない」（データーベースがない）といったエラーが発生したときに、すぐにスタッフ（PDO）に知らせる設定。
・PDO::ATTR_EMULATE_PREPARES => false: これは、ホテルのスタッフ（PDO）が正確に予約内容を確認するようにするための設定。

<catchブロック>
catch (PDOException $e) {
    echo '接続失敗: ' . $e->getMessage();
    exit();
}
#例え
チェックインを試みたけど、予約が見つからなかった場合どうしますか？カウンターで「予約が見つかりません」と伝えられるでしょう。この部分が「catchブロック」に相当します。

#エラー処理
・catch (PDOException $e): これは、もしチェックインがうまくいかなかったら（例: 予約が見つからなかったら）、エラーメッセージをキャッチして処理します。
・echo '接続失敗: ' . $e->getMessage();: ここでは、エラーメッセージを表示します。「接続失敗: 〇〇」という形で、何が問題だったかを教えてくれます。
・exit();: そして、そこで処理を終了します。これ以上進めることができないためです。

    |
    +--> [成功: PDOオブジェクトを生成して保持]
    |
    +--> [失敗: 例外をキャッチしてエラーメッセージを表示]
    |
    v
[リクエストに基づいて処理を選択]
    |
    +--> [insertPost()]
    |      |
    |      v
    |    [SQL文の準備]
    |      |
    |    [パラメータのバインド]
    |      |
    |    [クエリの実行]
    |      |
    |    [完了]
    |
    +--> [fetchAllPosts()]
    |      |
    |    [SQL文の準備]
    |      |
    |    [クエリの実行]
    |      |
    |    [結果を配列で返す]
    |      |
    |    [完了]
    |
    +--> [searchPosts()]
    |      |
    |    [SQL文の準備]
    |      |
    |    [パラメータのバインド]
    |      |
    |    [クエリの実行]
    |      |
    |    [結果を配列で返す]
    |      |
    |    [完了]
    |
    +--> [fetchPostsByPage()]
    |      |
    |    [SQL文の準備]
    |      |
    |    [パラメータのバインド]
    |      |
    |    [クエリの実行]
    |      |
    |    [結果を配列で返す]
    |      |
    |    [完了]
    |
    +--> [countAllPosts()]
    |      |
    |    [SQL文の準備]
    |      |
    |    [クエリの実行]
    |      |
    |    [投稿総数を返す]
    |      |
    |    [完了]
    |
    +--> [deletePost()]
    |      |
    |    [画像パス取得]
    |      |
    |    [画像削除 (unlink)]
    |      |
    |    [SQL文の準備]
    |      |
    |    [パラメータのバインド]
    |      |
    |    [クエリの実行]
    |      |
    |    [完了]
    |

<insertPostメソッド>
# 呼び出しもと
呼び出しもとは、Boardクラス。タイトル、コメントが入力されており、画像アップロードに成功していればinsertPostメソッドを使って、投稿をデータベースに保存

if ($_SESSION['title'] != '' && $_SESSION['comment'] != '' && $imagePath !== false) {
    $title = $_SESSION['title'];
    $comment = $_SESSION['comment'];
    $userId = $_SESSION['user_id'];  // ログインユーザーIDを取得
    $this->db->insertPost($title, $comment, $userId, $imagePath);
    unset($_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path']);
}


# データの準備：箱にデータを入れる
public function insertPost($title, $comment, $user_id, $imagePath)

    -説明
        この部分は、insertPostメソッドの宣言です。ここで、$title、$comment、$user_id、$imagePathという4つのデータを引数として受け取ります。これらのデータは、後でデータベースに送るために使います。このデータが、例え話の「貴重なデータ」であり、これから箱に詰めるものです。

    -例え：
        あなたがいくつかのデータ（タイトル、コメント、ユーザーID、画像パス）を持っているとしましょう。それぞれのデータは、貴重なもので、正確に安全に届ける必要があります。このデータを、安全な「箱」に入れて送ることにします。


# SQL文を準備（SQLステートメント、SQLへの命令文、プレースホルダーの準備）：箱のラベルを作る
$stmt = $this->pdo->prepare('INSERT INTO board_info (title, comment, user_id, image_path) VALUES (:title, :comment, :user_id, :image_path)');

    -説明
        この行では、データベースに送るためのSQL文を準備しています。prepareメソッドを使って、SQL文の「テンプレート」を作ります。VALUES (:title, :comment, :user_id, :image_path)の部分が、箱のラベルにあたります。ここでは具体的なデータはまだ入っておらず、どのデータがどこに入るかを示す「プレースホルダ」と呼ばれるものが使われています。
        $stmtという変数名は、ステートメントを意味しています。ステートメントとは命令文のことです。
        prepareメソッドは、プレースホルダーを準備するためのメソッド。

    -例え：
        次に、データを送るための「箱」のラベルを作ります。このラベルには、何が入っているのかが書かれていますが、まだ具体的なデータは書かれていません。例えば、「タイトルを入れる場所」「コメントを入れる場所」などと書かれています。このラベルがSQL文のテンプレートに相当します。


# データを箱に詰める：プレースホルダにデータを入れる
    $stmt->bindValue(':title', $title, PDO::PARAM_STR);
    $stmt->bindValue(':comment', $comment, PDO::PARAM_STR);
    $stmt->bindValue(':user_id', $user_id, PDO::PARAM_INT);
    $stmt->bindValue(':image_path', $imagePath, PDO::PARAM_STR);

    -説明
        この部分では、受け取ったデータをSQL文のプレースホルダに詰めています。bindValueメソッドを使って、$title、$comment、$user_id、$imagePathのデータをそれぞれ:title、:comment、:user_id、:image_pathというプレースホルダに代入しています。これが、データを箱の中の指定された場所に詰める作業にあたります。
        bindValueメソッドは、SQL文に含まれるプレースホルダー（:で始まる部分）に実際のデータを結びつけるためのメソッドです。この結びつける操作を「バインド」と言います。

    -例え
        次に、準備したラベルに従って、各データを箱の中の適切な場所に詰めます。具体的には、「タイトル」を「タイトル用の場所」に、「コメント」を「コメント用の場所」に入れていきます。このプロセスが、SQL文のプレースホルダにデータを代入する作業にあたります。


#安全に箱を閉じる：SQLインジェクション対策
    -説明
        ここで重要なのは、bindValueを使うことで、データが適切に保護されている点です。プレースホルダを使うことで、SQLインジェクション攻撃からデータを守ることができます。これが、箱をしっかり閉じて、安全に保つという部分にあたります。

    -例え
        この箱にはしっかりと蓋がされており、外部から箱の中身に触れられないようになっています。これがSQLインジェクション対策に相当します。箱がしっかりと閉じられていることで、データが改ざんされたり、悪意のあるコードが紛れ込んだりすることを防ぎます。


# 箱をデータベースに送る：SQL文の実行
    $stmt->execute();

    -説明
        最後に、executeメソッドを使って、準備が整ったSQL文を実行します。これにより、データベースに箱を送り、その中のデータがデータベースに保存されます。データベース側では、送られてきたデータを適切な場所に保存する処理が行われます。
        executeメソッドは、prepareとbindValueで準備したSQL文を実際にデータベースに送って、処理を実行するためのメソッドです。

    -例え
        最後に、この安全な箱をデータベースに送ります。データベースは、この箱を受け取り、ラベルを見て、中に入っているデータを正しい場所に保存します。これがSQL文を実行して、データベースにデータを保存するプロセスです。


<fetchAllPostsメソッド 今は使っていない>
    まず、このコードはPHPでデータベースから投稿情報を取得するためのメソッド（関数）です。

# データベースクエリの準備
$stmt = $this->pdo->prepare('SELECT * FROM board_info ORDER BY id DESC');

-説明
この行は、データベースに対してSQLクエリ（命令）を準備する部分です。
$this->pdo: これは、PDO（PHP Data Objects）というPHPのデータベースアクセスクラスのインスタンスです。このインスタンスを使ってデータベースに接続し、操作を行います。
prepareメソッドは、プレースホルダーを準備するためのメソッド。
SELECT *: SQLの命令で、「すべての列を選択する」という意味です。
FROM board_info: board_info という名前のテーブルからデータを取得します。
ORDER BY id DESC: id という列を基準にして、データを降順（大きい順）に並べ替えて取得します。

-例え
これは、書店のカウンターで「棚にある本をすべて持ってきて、IDが大きい順に並べてください」と注文しているようなものです。

# クエリの実行
$stmt->execute();

-説明
この行は、準備したSQLクエリをデータベースに送信して実行する部分です。
execute() メソッドを呼び出すことで、データベースが指示に従ってデータを取得します。

-例え
先ほどの書店の例で言うと、店員が注文票を見て、実際に棚から本を取り出す作業を開始するようなものです。

# 結果の取得と返却
return $stmt->fetchAll(PDO::FETCH_ASSOC);

-説明
この部分は、データベースから取得した結果を配列の形で取得し、そのまま呼び出し元に返す部分です。
fetchAll() メソッドは、クエリの結果をすべて取得し、配列として返します。
PDO::FETCH_ASSOC:。このオプションは、データを連想配列の形式で取得することを意味します。連想配列とは、キー（列名）と値（データ）がペアになった配列です。

-具体的にどのような形で帰ってくるか
[
    [
        "id" => 1,
        "title" => "掲示板の初投稿",
        "comment" => "これは初めての投稿です。",
        "user_id" => 101,
        "image_path" => "uploads/image1.jpg",
        "created_at" => "2024-08-01 12:34:56",
        "updated_at" => "2024-08-01 13:00:00"
    ],
    [
        "id" => 2,
        "title" => "PHPについて",
        "comment" => "PHPの質問です。",
        "user_id" => 102,
        "image_path" => "uploads/image2.jpg",
        "created_at" => "2024-08-02 14:20:00",
        "updated_at" => "2024-08-02 15:00:00"
    ],
    // さらに多くの投稿データが続く
]

-例え
これは、取り出した本の一覧をタイトルや著者名などの情報を含めたリストに整理し、それを注文した人に渡すような作業です。



<searchPostsメソッド>
public function searchPosts($keyword, $page, $limit)
    {
        $offset = ($page - 1) * $limit;
        $stmt = $this->pdo->prepare(
            'SELECT * FROM board_info
             WHERE title LIKE :keyword1 OR comment LIKE :keyword2
             ORDER BY id DESC
             LIMIT :limit OFFSET :offset'
        );
        $stmt->bindValue(':keyword1', '%' . $keyword . '%', PDO::PARAM_STR);
        $stmt->bindValue(':keyword2', '%' . $keyword . '%', PDO::PARAM_STR);
        $stmt->bindValue(':limit', (int) $limit, PDO::PARAM_INT);
        $stmt->bindValue(':offset', (int) $offset, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

#処理の流れ
board.php → Board.php searchPostsメソッド → Database.php searchPostsメソッド

#メソッドの役割
この searchPosts メソッドは、掲示板アプリケーション内で、ユーザーが入力したキーワードに基づいて投稿を検索し、その検索結果をページごとに表示するための機能を提供します。

#メソッド宣言部分
public function searchPosts($keyword, $page, $limit)

-説明
$keyword:
ユーザーが検索ボックスに入力したキーワード。これを基に、タイトルやコメントの中から一致する投稿を検索します。
$page:
現在表示するページ番号。ページネーション（複数ページに分割して表示）を実現するために使います。
$limit:
1ページに表示する投稿の数。例えば、1ページに10件表示する場合、この値は10になります。

#オフセットの計算
$offset = ($page - 1) * $limit;

-説明
このコードは、データベースからデータを取得するときに、「どこからデータを取り始めるか」を計算しています。具体的には、ページネーションと呼ばれる機能を実現するために使われます。このコードは、データベースからどの位置からデータを取り始めるかを決めるために使われます。ページネーションを実現するために、特定のページに表示するデータのスタート位置を計算しています。

-具体例
1ページ目:
$page = 1 のとき、$offset は (1 - 1) * 10 = 0 です。つまり、最初のデータから表示を始めます。
2ページ目:
$page = 2 のとき、$offset は (2 - 1) * 10 = 10 です。つまり、11番目のデータから表示を始めます。
3ページ目:
$page = 3 のとき、$offset は (3 - 1) * 10 = 20 です。つまり、21番目のデータから表示を始めます。

#SQLクエリの準備
$stmt = $this->pdo->prepare(
    'SELECT * FROM board_info
     WHERE title LIKE :keyword1 OR comment LIKE :keyword2
     ORDER BY id DESC
     LIMIT :limit OFFSET :offset'
);

#SQLクエリ:
•SELECT * FROM board_info: board_info テーブルからすべての列（データ）を選択するという意味です。
•WHERE title LIKE :keyword1 OR comment LIKE :keyword2: ここでは、投稿のタイトルまたはコメントがキーワードと一致するものを検索しています。LIKE は部分一致検索を行うための条件です。
•ORDER BY id DESC: 検索結果を投稿IDの降順（新しいものが上）で並べ替えます。
•LIMIT :limit OFFSET :offset: 取得する投稿の数を制限し、どこから取得を始めるかを指定します。これにより、ページごとに投稿を表示できます。

#SQLクエリとCRUD操作の対応
-Create（作成）:
•SQLクエリ: INSERT INTO を使います。
•例: INSERT INTO users (username, password) VALUES ('john_doe', 'secret');
-Read（読み取り）:
•SQLクエリ: SELECT を使います。
•例: SELECT * FROM users WHERE username = 'john_doe';
-Update（更新）:
•SQLクエリ: UPDATE を使います。
•例: UPDATE users SET password = 'new_secret' WHERE username = 'john_doe';
-Delete（削除）:
•SQLクエリ: DELETE を使います。
•例: DELETE FROM users WHERE username = 'john_doe';

#結果の取得
return $stmt->fetchAll(PDO::FETCH_ASSOC);

-説明
•クエリの実行結果をすべて取得し、連想配列として返します。
•fetchAll() メソッドは、クエリの結果をすべて取得し、配列として返します。
•PDO::FETCH_ASSOC: これは、結果を連想配列の形式で取得することを意味します。連想配列とは、キー（列名）と値（データ）がペアになった形式です。


<countSearchResultsメソッド>
public function countSearchResults($keyword)
    {
        $stmt = $this->pdo->prepare('SELECT COUNT(*) FROM board_info WHERE title LIKE :keyword1 OR comment LIKE :keyword2');
        $stmt->bindValue(':keyword1', '%' . $keyword . '%', PDO::PARAM_STR);
        $stmt->bindValue(':keyword2', '%' . $keyword . '%', PDO::PARAM_STR);
        $stmt->execute();
        return $stmt->fetchColumn();
    }

#処理の流れ
    board.php（ページネーションの総ページ数の表示に使用） → Board.php countSearchResultsメソッド → Database.php countSearchResultsメソッド

#SQLクエリの準備
    $stmt = $this->pdo->prepare('SELECT COUNT(*) FROM board_info WHERE title LIKE :keyword1 OR comment LIKE :keyword2');

    -説明
        •ここでは、データベースに対して実行するSQLクエリを準備しています。
        •SQL文の意味:
            SELECT COUNT(*): これは、条件に一致する行（データ）がいくつあるかを数えるためのSQL文です。
            FROM board_info: board_info というテーブルからデータを取得します。このテーブルには掲示板の投稿が保存されています。
            WHERE title LIKE :keyword1 OR comment LIKE :keyword2: ここで、投稿のタイトルまたはコメントに、ユーザーが入力したキーワードが含まれているかどうかを調べます。

#戻り値
    return $stmt->fetchColumn();

    -fetchColumn メソッド:
        fetchColumn は、クエリの結果から最初の列の値を取得するためのメソッドです。この場合は、COUNT(*) の結果（つまり、キーワードに一致する投稿の数）が返されます。



<fetchPostsByPageメソッド>
#処理の流れ
board.php $post_list → Board.php getPostメソッド → Database.php fetchPostsByPageメソッド

public function fetchPostsByPage($page, $limit)
    {
        $offset = ($page - 1) * $limit;
        $stmt = $this->pdo->prepare('SELECT * FROM board_info ORDER BY id DESC LIMIT :limit OFFSET :offset');
        $stmt->bindValue(':limit', $limit, PDO::PARAM_INT);
        $stmt->bindValue(':offset', $offset, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

#メソッドの概要
public function fetchPostsByPage($page, $limit)
-説明
・$page:
現在表示したいページ番号を指定します。たとえば、1ページ目、2ページ目など。
・$limit:
1ページに表示する投稿の数を指定します。たとえば、1ページに10件の投稿を表示する場合、この値は10になります。

#オフセットの計算
$offset = ($page - 1) * $limit;

-$page - 1をする理由
$offset = ($page - 1) * $limit; という計算において、$page から1を引くのは、ページネーションの仕組みを正しく動作させるためです。

-ページネーションの基本
ページネーションとは、データを複数のページに分けて表示する機能です。たとえば、1ページに10件のデータを表示する場合、次のようになります。
•	1ページ目: 1件目から10件目まで
•	2ページ目: 11件目から20件目まで
•	3ページ目: 21件目から30件目まで

-オフセットとは
オフセット（$offset）は、データベースからデータを取得するときに、「何件目から取得を始めるか」を指定するためのものです。

-($page - 1) の意味

$page は現在のページ番号を示しますが、データを取得するときのオフセットを計算する際には、$page から1を引いて計算する必要があります。

-理由
•1ページ目の場合: $page が1なので、($page - 1) * $limit は (1 - 1) * $limit となり、0 になります。つまり、データベースから最初のデータ（1件目）から取得を開始します。
•2ページ目の場合: $page が2なので、($page - 1) * $limit は (2 - 1) * $limit となり、$limit そのものがオフセットになります。たとえば、$limit が10なら、オフセットは10です。これは、データベースから11件目からデータを取得することを意味します。

-具体例
たとえば、1ページに10件のデータを表示する場合を考えます。
•1ページ目:
•$page = 1
•オフセット: ($page - 1) * $limit = (1 - 1) * 10 = 0
•0番目（1件目）からデータを取得

•2ページ目:
•$page = 2
•オフセット: ($page - 1) * $limit = (2 - 1) * 10 = 10
•10番目（11件目）からデータを取得

•3ページ目:
•$page = 3
•オフセット: ($page - 1) * $limit = (3 - 1) * 10 = 20
•20番目（21件目）からデータを取得

-まとめ
•($page - 1) で1を引くのは、データ取得の開始位置（オフセット）を正しく計算するためです。
•1ページ目の場合はオフセットが 0 になり、最初のデータから取得を開始します。2ページ目以降では、前のページに表示したデータ数分だけオフセットを設定し、その次のデータから取得を始めます。

この計算により、ページネーションが正しく機能し、ユーザーが見るページに適切なデータが表示されるようになります。

#SQLクエリの準備
$stmt = $this->pdo->prepare('SELECT * FROM board_info ORDER BY id DESC LIMIT :limit OFFSET :offset');
このコードでは、board_infoの何件目の情報（offset）から、何件分（limit）の情報を持ってくるのかを決めている

-説明
•ORDER BY id DESC:
id を基準に投稿を降順（つまり、新しいものが最初に来る順）で並べ替えます。
•LIMIT :limit:
取得するデータの最大件数を指定します。例えば、LIMIT 10 とバインドされた場合、10件のデータを取得します。
•OFFSET :offset:
データの取得を開始する位置を指定します。例えば、OFFSET 0 とバインドされた場合、最初のデータ（最新のデータ）から取得します。

#プレースホルダーへの値のバインド
$stmt->bindValue(':limit', $limit, PDO::PARAM_INT);
$stmt->bindValue(':offset', $offset, PDO::PARAM_INT);

-説明
prepareメソッドで、箱のラベルを作って、どの情報（命令文）をどこの箱に入れるか決めておいたものを、bindValueで、どこに入れるか決めておいた箱に情報（命令文）を入れて、executeメソッドでその情報が入った箱をデーターベースへ送る

#結果の取得
return $stmt->fetchAll(PDO::FETCH_ASSOC);

-説明
•fetchAll(PDO::FETCH_ASSOC):
この部分では、データベースから返ってきた「箱」の中身を取り出す作業を行っています。
fetchAll() は、返ってきたすべてのデータを取得するためのメソッドです。これは、「箱の中に入っているすべてのデータを取り出してください」という命令に相当します。


<countAllPostsメソッド>
public function countAllPosts()
    {
        $stmt = $this->pdo->query('SELECT COUNT(*) FROM board_info');
        return $stmt->fetchColumn();
    }

#メソッドの概要
public function countAllPosts()
    {
        $stmt = $this->pdo->query('SELECT COUNT(*) FROM board_info');
        return $stmt->fetchColumn();
    }
この countAllPosts メソッドは、掲示板などのアプリケーションで「すべての投稿がいくつあるのか」を数えて、その数を返します。

#処理の流れ
board.php $total_posts変数 getTotalPostCountメソッド呼び出し → Board.php getTotalPostCountメソッド → Database.phpのcountAllPostsメソッドの呼び出し

#SQLクエリ
$stmt = $this->pdo->query('SELECT COUNT(*) FROM board_info');
-説明
行数を数えるだけで、データー改竄の恐れがなく、SQLインジェクション対策を行う必要がないためprepareではなく、queryを使用している

#結果の取得
return $stmt->fetchColumn();
-説明
fetchColumn() は、クエリの結果の最初の列を取得するメソッドです。この場合、COUNT(*) の結果、つまり投稿の総数を取得します。


<getImagePathメソッド>
public function getImagePath($post_id)
{
    $stmt = $this->pdo->prepare('SELECT image_path FROM board_info WHERE id = :id');
    $stmt->bindValue(':id', $post_id, PDO::PARAM_INT);
    $stmt->execute();
    return $stmt->fetchColumn();
}

#処理の流れ
DeleteConfirmクラスのhandleRequestメソッド → handleRequestメソッドでDatabaseクラスのdeletePostメソッドの呼び出し → deletePostメソッドでgetImagePathメソッドを呼び出し

#メソッドの概要
このメソッドは、掲示板アプリケーションの中で、投稿ID（post_id）を使って、その投稿に関連する画像のファイルパスをデータベースから取得し、そのパスを返します。つまり、「特定の投稿に紐づいた画像の場所」を探し出すためのものです。

#メソッドの定義
public function getImagePath($post_id)
-説明
これは、getImagePath という名前のメソッドを定義しています。このメソッドは、投稿のID（$post_id）を受け取り、そのIDに関連する画像のパスをデータベースから取得します。
-例え
これは、図書館で「特定の本（投稿）に付いているラベル（画像のパス）を見つける」作業を行うようなものです。

#SQLクエリ
$stmt = $this->pdo->prepare('SELECT image_path FROM board_info WHERE id = :id');
-説明
この部分では、データベースに対して「board_info というテーブルから、特定の投稿ID（id）に対応する画像のパス（image_path）を取得して欲しい」という命令を準備しています。
-例え
これは、図書館員に「特定の本のラベル（画像のパス）を探して欲しい」とお願いしているようなものです。

#結果の取得
return $stmt->fetchColumn();
-説明
fetchColumn() メソッドは、クエリの結果から最初の列（この場合は image_path）を取得します。


<deletePostメソッド>
public function deletePost($post_id)
    {
        $imagePath = $this->getImagePath($post_id);
        if (!empty($imagePath) && file_exists($imagePath)) {
            unlink($imagePath);
        }

        $stmt = $this->pdo->prepare('DELETE FROM board_info WHERE id = :id');
        $stmt->bindValue(':id', $post_id, PDO::PARAM_INT);
        $stmt->execute();
    }

#処理の流れ
DeleteConfirmクラスのhandleRequestメソッド → handleRequestメソッドでDatabaseクラスのdeletePostメソッドの呼び出し

#メソッドの概要
このメソッド deletePost は、特定の投稿ID（$post_id）を使って、その投稿に関連するデータと画像を削除します。具体的には、投稿に紐づいた画像ファイルをサーバーから削除し、その後にデータベースから投稿のデータを削除します。

#画像パスの取得
$imagePath = $this->getImagePath($post_id);
-説明
ここでは、投稿IDを使って、その投稿に関連する画像ファイルのパスを取得しています。この getImagePathメソッドで、特定の投稿IDに対応する画像の場所をデータベースから探し出します。

#画像ファイルの削除チェック
if (!empty($imagePath) && file_exists($imagePath)) {
    unlink($imagePath);
}
-説明:
ここでは、画像ファイルのパスが空でないか（!empty($imagePath)）を確認し、そのファイルがサーバー上に実際に存在するか（file_exists($imagePath)）を確認しています。もし存在しているなら、その画像ファイルを削除します（unlink($imagePath)）。
empty は、変数が「空」であるかどうかを調べるためのPHPの構文です。具体的には、変数が次のいずれかの状態にある場合に true を返します。
file_exists は、指定されたパスにファイルやディレクトリが存在するかどうかを確認するためのPHPの組み込み関数です。

#画像ファイルの削除
unlink($imagePath);
-説明
unlink は、指定されたファイルをサーバーから削除するためのPHP組み込み関数です。実際にファイルを削除する操作を行います。

#投稿データの削除
$stmt = $this->pdo->prepare('DELETE FROM board_info WHERE id = :id');
$stmt->bindValue(':id', $post_id, PDO::PARAM_INT);
$stmt->execute();
-説明:
ここでは、データベースから指定された投稿IDに対応する投稿データを削除します。まず、DELETE FROM board_info WHERE id = :id というSQL文を準備し（prepare）、次にそのIDに値をバインド（bindValue）します。最後に、このSQL文を実行して投稿データを削除します（execute）。












<SessionManager.php フローチャート>
[セッション開始を確認 (startSession)]
    |
    v
[セッションが開始されているか確認 (session_status())]
    |
    +----> [セッションが開始されていない場合]
    |         |
    |         v
    |    [セッションの設定を変更 (ini_set)]
    |         |
    |    [セッションを開始 (session_start)]
    |         |
    |    [セッション有効期限の確認 (isSessionExpired)]
    |         |
    |         +----> [有効期限が切れている場合]
    |                    |
    |               [セッションを破棄 (session_unset, session_destroy)]
    |                    |
    |               [新しいセッションを開始 (session_start)]
    |                    |
    |               [セッションIDを再生成 (session_regenerate_id)]
    |
    v
[最終アクティビティ時間を更新 ($_SESSION['LAST_ACTIVITY'])]
    |
    v
[終了]

------------------------------------------------------

[セッションの有効期限を確認 (isSessionExpired)]
    |
    v
[最終アクティビティ時間が存在するか確認]
    |
    +----> [存在しない場合]
    |         |
    |         v
    |    [有効期限が切れていない (false)]
    |
    +----> [存在する場合]
              |
         [現在時刻 - 最終アクティビティ時間 > 1800秒か確認]
              |
         +----> [有効期限が切れている (true)]
         |         |
         |    [有効期限が切れていない (false)]
         |
         v
    [有効期限が切れている場合は true を返す]
    [有効期限が切れていない場合は false を返す]

------------------------------------------------------

[CSRFトークンを生成 (setToken)]
    |
    v
[ランダムなトークンを生成 (uniqid, sha1)]
    |
    v
[トークンをセッションに保存 ($_SESSION['board_token'])]
    |
    v
[トークンを返す (return $token)]

------------------------------------------------------

[CSRFトークンを検証 (validateToken)]
    |
    v
[セッションにトークンが存在するか確認 ($_SESSION['board_token'])]
    |
    +----> [トークンが存在しない、または一致しない場合]
    |         |
    |    [不正な投稿として処理を終了 (exit)]
    |
    v
[トークンをセッションから削除 (unset $_SESSION['board_token'])]
    |
    v
[フォームからトークンを削除 (unset $_POST['board_token'])]

------------------------------------------------------

[ユーザーがログインしているか確認 (isLoggedIn)]
    |
    v
[セッションに user_id が存在するか確認 ($_SESSION['user_id'])]
    |
    v
[存在する場合は true、存在しない場合は false を返す] 返した値はBoard.phpのconstruct()で使われる

------------------------------------------------------

[ユーザーをログイン状態に設定 (loginUser)]
    |
    v
[セッションに user_id を保存 ($_SESSION['user_id'] = $user_id)]

------------------------------------------------------

[ログアウト処理 (logoutUser)]
    |
    v
[セッションデータを削除 (session_unset)]
    |
    v
[セッションを破棄 (session_destroy)]


<DeleteConfirm.php フローチャート>
[開始]
    |
    v
[DeleteConfirmクラスのインスタンス作成]
    |
    v
[セッションの開始 (startSession())]
    |
    v
[POSTリクエストを処理 (handleRequest())]
    |
    v
[削除ボタンが押されたか？ (isset($_POST['delete_btn']))]
    |----> [はい] -----> [削除対象の投稿情報を取得 (getPostInfo())]
    |                          |
    |                          v
    |                  [POSTリクエストに投稿IDが含まれているか確認 (isset($_POST['post_id']) && $_POST['post_id'] != '')]
    |                          |
    |                          v
    |                  [投稿IDをセッションに保存 ($_SESSION['id'] = $_POST['post_id'])]
    |                          |
    |                          v
    |                  [データベース接続を取得 ($pdo = $this->db->getPdo())]
    |                          |
    |                          v
    |                  [投稿情報をデータベースから取得 (SELECT id, title, comment, image_path)]
    |                          |
    |                          v
    |                  [投稿情報をセッションに保存 ($_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path'])]
    |
    |----> [削除確定ボタンが押されたか？ (isset($_POST['delete_submit_btn']))]
    |                          |
    |                          v
    |                  [CSRFトークンを検証 (validateToken())]
    |                          |
    |                          v
    |                  [トークンが無効なら "不正な投稿です" を表示]
    |                          |
    |                          v
    |                  [投稿をデータベースから削除 ($this->db->deletePost($_SESSION['id']))]
    |                          |
    |                          v
    |                  [セッションから投稿情報を削除 (unset($_SESSION['id'], $_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path']))]
    |                          |
    |                          v
    |                  [削除成功ページにリダイレクト (header('Location: delete-success.php'))]
    |
    |----> [キャンセルボタンが押されたか？ (isset($_POST['cancel_btn']))]
                               |
                               v
                       [セッションから投稿情報を削除 (unset($_SESSION['id'], $_SESSION['title'], $_SESSION['comment'], $_SESSION['image_path']))]
                               |
                               v
                       [掲示板ページにリダイレクト (header('Location: board.php'))]
    |
    v
[終了]

<SessionManagerクラスの概要>
SessionManagerクラスは、ユーザーセッションの管理を行うための機能を提供します。セッションとは、ウェブサイトでユーザーの状態を一時的に保存するための仕組みです。例えば、ログイン状態やフォームに入力したデータを保持するために使われます。

<startSession() メソッド>
public function startSession()
{
    // すでにセッションが開始されているか確認
    if (session_status() == PHP_SESSION_NONE) {
        ini_set('session.gc_maxlifetime', 1800);
        ini_set('session.gc_divisor', 1);
        session_start();

        // セッションの有効期限をチェックし、期限切れならセッションを破棄
        if ($this->isSessionExpired()) {
            session_unset();
            session_destroy();
            session_start(); // 新しいセッションを開始
        }

        session_regenerate_id(true);
    }

    // 最終アクティビティ時間を更新
    $_SESSION['LAST_ACTIVITY'] = time();
}

#処理の流れ
classesディレクトリのほとんどのファイルで使用

#セッションの開始:
 •session_status()
session_status()はPHPの組み込み関数です。session_status()関数は、現在のセッションの状態を返します。この関数を使用すると、セッションがまだ開始されていない (PHP_SESSION_NONE)、既に開始されている (PHP_SESSION_ACTIVE)、またはセッションが無効 (PHP_SESSION_DISABLED) のいずれかを確認できます。
 •ini_set('session.gc_maxlifetime', 1800)
ini_set は、PHPの設定をプログラムの実行中に変更するための関数です。普段は設定ファイル（php.ini）で管理されている設定を、一時的に変更したいときに使います。
•session.gc_maxlifetime:
	•この設定は、PHPのセッションが有効である最大時間（秒単位）を定義します。
	•セッションとは、ユーザーがウェブサイトを訪れている間に、サーバー側でユーザーの情報を保持する仕組みです。例えば、ログイン情報やカートの中身などのデータを一時的に保存します。
	•gc_maxlifetime は “ガーベッジコレクション（garbage collection）最大有効期間” の略で、セッションデータが無効になるまでの時間を設定します。
 •ini_set の使い方
ini_set('設定項目', '設定値');
今回のコードでは、セッションの有効期限を30分に設定したいので、上記のような記述になっている
 •session_start(): 新しいセッションを開始します。

#セッションの有効期限確認:
 •isSessionExpired()
isSessionExpired() は、PHPでセッションの有効期限が切れているかどうかを確認するメソッドです。このメソッドは、ユーザーがセッションを開始してから一定の時間が経過したかどうかを判断し、セッションが有効期限内であるかどうかをチェックするメソッドです。

#セッションIDの再生成:
 •session_regenerate_id(true)
session_regenerate_id(true); は、セッションIDを再生成し、セッションデータの安全性を高めるために非常に重要なセキュリティ対策です。初心者の方にも理解しやすいように言うと、「現在のセッションを守るために、定期的に新しい鍵（ID）を作り直す」ことです。
このコードは、セッションIDを再生成します。session_regenerate_id(true); というコードは、現在のセッションIDを新しいものに再生成し、セッションハイジャック（不正アクセス）などのセキュリティリスクを防ぐために使われます。

#session_regenerate_id(true); の意味と役割
-セッションIDの再生成:
 •セッションIDは、ユーザーを一意に識別するために使われる識別子です。PHPでは、ユーザーがサイトにアクセスするたびにこのセッションIDが生成されます。
 •session_regenerate_id() を呼び出すと、新しいセッションIDが生成されます。これにより、古いセッションIDが無効化され、セッションIDを使った攻撃を防ぐことができます。
-true パラメータの意味
 •session_regenerate_id() の引数に true を渡すと、古いセッションデータが削除されます。
 •もし false を渡すと、古いセッションデータは保持されたまま、新しいセッションIDだけが生成されます。しかし、セキュリティの観点からは true を使うことが推奨されます。

#最終アクティビティ時間の更新:
 •$_SESSION['LAST_ACTIVITY'] = time();: ユーザーが最後にアクティブだった時間をセッションに記録します。


<isSessionExpired() メソッド> エクスパイアド
private function isSessionExpired()
{
    if (isset($_SESSION['LAST_ACTIVITY']) && (time() - $_SESSION['LAST_ACTIVITY'] > 1800)) {
        return true;
    }
    return false;
}
#名前の意味
•is: 英語で「〜かどうかを確認する」という意味を持つ。この場合、「セッションが期限切れかどうか」を確認することを示しています。
•Session: 現在のユーザーのセッション（つまり、ログイン状態や一時的なデータの保持状態）を指します。
•Expired: 「期限切れ」という意味で、セッションの有効期間が過ぎてしまった状態を表します。

#呼び出し
startSessionメソッドで呼び出される。セッションの期限が切れいているか、いないか確認するために使われる

#メソッドの概要
このコードは、セッションが有効期限切れかどうかを確認するためのメソッドです。セッションが期限切れであれば true を返し、期限切れでなければ false を返します。
このコードは、ユーザーが最後に何か操作をしてから30分以上経過したかどうかを確認するためのものです。もし30分以上経過していれば、そのセッションは「期限切れ」として扱われ、再度ログインを求められるなどの処理が行われることが多いです。

#if (isset($_SESSION['LAST_ACTIVITY']) && (time() - $_SESSION['LAST_ACTIVITY'] > 1800))

#isset($_SESSION['LAST_ACTIVITY']):
isset($_SESSION['LAST_ACTIVITY']) は、セッションに LAST_ACTIVITY という名前の情報があるかどうかを確認します。この情報が存在すれば true を返し、存在しなければ false を返します。セッションがアクティブかどうか、つまりユーザーが最後に操作した時間が記録されているかを確認するために使われます。
•isset:
	•PHPの関数で、変数が「存在しているかどうか」をチェックします。
	•もし変数が存在し、値が null ではない場合に true を返します。存在しないか、null であれば false を返します。
•$_SESSION:
	•PHPのスーパーグローバル変数です。これは「セッション」に関連する情報を保存するために使われます。セッションは、ユーザーがサイトを訪れている間、そのユーザーに関連するデータを一時的に保持するために使われます。
•'LAST_ACTIVITY':
	•これはセッション内の特定のデータのキーです。$_SESSION['LAST_ACTIVITY'] は、セッションが最後にアクティブだった（つまり、ユーザーが何か操作をした）時間を記録しています。

#time() - $_SESSION['LAST_ACTIVITY'] > 1800
このコードは、セッションが「最後に活動した時間」から「現在までの経過時間」が、一定の時間（ここでは1800秒、つまり30分）を超えているかどうかを確認しています。
•time():
	•PHPの関数で、現在のUnixタイムスタンプ（現在時刻を秒単位で表した数値）を返します。例えば、1970年1月1日からの経過秒数です。
•$_SESSION['LAST_ACTIVITY']:
	•これはセッションの中に保存された、ユーザーが最後に何か操作をした時間のタイムスタンプ（特定の日時や時間を表す数値）です。
•time() - $_SESSION['LAST_ACTIVITY']:
	•現在の時間から、最後に操作が行われた時間を引いた結果を求めます。これにより、最後の活動から現在までの経過時間（秒）がわかります。
•> 1800:
	•この部分は、計算された経過時間が1800秒（30分）を超えているかどうかをチェックします。

#return true;
•この行は、条件が満たされたとき（つまり、セッションが期限切れと判断されたとき）に true を返します。
•true は「セッションが期限切れである」ことを意味します。

#return false;
    •もし上記の条件が満たされなかった場合（セッションが期限切れではない場合）、この行で false を返します。
	•false は「セッションはまだ有効である」ことを意味します。



<setToken() メソッド>
public function setToken()
{
    $token = sha1(uniqid(mt_rand(), true));
    $_SESSION['board_token'] = $token;
    return $token;
}

#呼び出し
色々なクラス

#メソッドの概要
このメソッドは、セキュリティトークンを生成してセッションに保存し、後でそのトークンを使って不正なリクエストが行われていないか確認するためのものです。これは、CSRF（クロスサイトリクエストフォージェリ）という攻撃から保護するために使われます。

#sha1(uniqid(mt_rand(), true)) の部分
•uniqid(mt_rand(), true):
    •uniqid()は、ユニークなIDを生成するための関数です。この関数は、通常、現在の時間に基づいて一意な文字列を生成しますが、mt_rand()というランダムな数値を使ってさらにランダム性を高めています。
	•trueを指定することで、生成されるIDがより長くなり、さらにユニーク性が高まります。
	•例えるなら、「誰も持っていない特別な鍵」を作り出すようなものです。
•sha1():
	•sha1()は、文字列を特定の長さの暗号化されたハッシュ値に変換する関数です。生成されたユニークなIDをsha1()で暗号化して、安全性を高めています。
	•これにより、トークンが予測しにくくなり、セキュリティが向上します。

#uniqid(mt_rand(), true) の詳しい説明
uniqid()関数は、PHPでユニークな（つまり、他と重複しない）IDを生成するための関数です。このIDは通常、現在の時間に基づいて作られますが、それだけでは他のIDと重複する可能性がわずかにあります。そこで、mt_rand()という乱数（ランダムな数字）を使ってさらにランダム性を加え、IDがよりユニークになるようにしています。

-uniqid()とは？
	•uniqid()は、システムの現在の時間を基にしてユニークな文字列を作ります。たとえば、1970年1月1日から現在までの秒数やマイクロ秒数を使ってIDを生成します。通常、このIDは他のIDと重ならないように設計されています。

-mt_rand()とは？
	•mt_rand()は、乱数を生成する関数です。「乱数」というのは、コンピュータがランダムに選んだ数字のことです。この数字をuniqid()に追加することで、IDがさらにランダムになり、同じIDが生成される可能性が非常に低くなります。
	•例えると、uniqid()が「何時何分何秒に鍵を作ったか」だとしたら、mt_rand()は「鍵の形をランダムに変える」ようなものです。これにより、鍵（ID）がより一層ユニークになります。

-true を指定する意味
	•uniqid()関数には、第二引数としてtrueを渡すことができます。このtrueを指定すると、生成されるIDがより長くなり、さらにユニーク性が増します。
	•trueを指定しない場合、IDは短めの文字列になりますが、trueを指定すると、IDが長くなり、ほかと重複する可能性がさらに低くなります。


#$_SESSION['board_token'] = $token;
	•生成されたトークンをセッションに保存しています。
	•$_SESSIONはPHPで使用されるスーパーグローバル変数で、サーバー側でユーザーごとに一時的にデータを保存するために使われます。この場合、board_tokenというキーにトークンを保存しています。
	•例えるなら、この特別な鍵を金庫にしまっておいて、必要なときに取り出して使うイメージです。

#return $token;
	•最後に、生成されたトークンを呼び出し元に返しています。
	•この返されたトークンは、フォームに隠しフィールドとして埋め込むなど、後で使うことができます。


<validateToken() メソッド>
public function validateToken($token)
{
    if (empty($_SESSION['board_token']) || ($_SESSION['board_token'] !== $token)) {
        exit('不正な投稿です');
    }
    unset($_SESSION['board_token']);
    unset($_POST['board_token']);
}
#名前の意味
“validateToken” は、英語で「トークンを検証する」という意味です。
発音は、「ヴァリデイト トークン」と読みます。
    •validate（ヴァリデイト）：検証する、確認する
    •token（トークン）：識別子、セキュリティのための一時的なキーや符号

#呼び出し
投稿リクエストを処理するメソッドのBoard.phpのhandlePostRequestメソッドでvalidateTokenメソッドが呼び出される

#メソッドの概要
このコードは、ウェブアプリケーションでセキュリティを確保するために、CSRF（クロスサイトリクエストフォージェリ）攻撃を防ぐ目的で使用されています。
このメソッドは、送信されたリクエストが正当なものであるかを確認し、もし不正なものであれば処理を終了します。また、一度使われたトークンを削除することで、次回のリクエストが同じトークンで不正に行われないようにしています。これはウェブアプリケーションのセキュリティを高めるために重要な役割を果たします。

#条件文のチェック:
if (empty($_SESSION['board_token']) || ($_SESSION['board_token'] !== $token))

-empty($_SESSION['board_token']):
    •$_SESSION['board_token']: これは、セッションに保存されているトークンです。セッションは、サーバー側でユーザーごとのデータを保持するために使います。
	•empty 関数: これは、変数が空かどうかをチェックする関数です。「空」というのは、変数に値がセットされていない場合や、値が 0、NULL、空の文字列 ("") などのときです。
	•empty($_SESSION['board_token']): これは、「セッションに保存されているトークンが空である（つまり、トークンが設定されていない）場合」という意味です。
-($_SESSION['board_token'] !== $token):
	•!== 演算子: これは「等しくない」という意味を持つ演算子です。つまり、左側の値と右側の値が同じでない場合に true になります。
	•$_SESSION['board_token']: これはセッションに保存されているトークンです。
	•$token: これは、ユーザーから送信されたトークンです。通常はフォームを送信する際に一緒に送られます。
	•$_SESSION['board_token'] !== $token: これは「セッションに保存されているトークンと、ユーザーから送られてきたトークンが一致しない場合」という意味です。
-条件文の全体:
	•||: これは「または」という意味です。つまり、条件Aが true であるか、条件Bが true である場合、全体として true になります。
	•if (empty($_SESSION['board_token']) || ($_SESSION['board_token'] !== $token)):
	•まず、セッションにトークンが保存されていない場合 (empty($_SESSION['board_token']) が true になる)。
	•または、セッションに保存されたトークンと、ユーザーから送られてきたトークンが一致しない場合 ($_SESSION['board_token'] !== $token が true になる)。
	•このどちらかが true であれば、次の処理（exit でスクリプトの実行を止める）が行われます。

#エラーメッセージの表示と処理の終了:
exit('不正な投稿です');
	•トークンが正しくない場合、つまり上記の条件が true であれば、この行が実行されます。exit 関数は、現在のスクリプトの実行を停止し、引数に指定したメッセージを表示します。ここでは「不正な投稿です」というメッセージが表示され、スクリプトが終了します。
    •exit は、PHPの関数の一つで、プログラムの実行を即座に終了させます。これが呼び出されると、それ以降のコードは実行されません。
	•exit に続く行は、すべて無視され、スクリプトが終了します。

#トークンの削除:
unset($_SESSION['board_token']); および unset($_POST['board_token']);
	-unset() 関数とは？
	    •unset() 関数は、PHPで使われる関数の一つです。この関数を使うと、指定された変数を削除することができます。

    -$_SESSION とは？
	    •$_SESSION は、サーバー側でユーザーの情報を一時的に保存しておくための特別な変数です。
	    •ウェブサイトを使っている間、ユーザーの状態や情報を覚えておくために使われます。
	    •$_SESSION['board_token'] は、セッションに保存されている board_token という名前のデータを指しています。

    -$_POST とは？
    	•$_POST は、フォームから送信されたデータを保存しておくための特別な変数です。
	    •ユーザーが掲示板に投稿したり、入力フォームにデータを入力して送信したとき、そのデータが $_POST に保存されます。
	    •$_POST['board_token'] は、フォームから送信された board_token という名前のデータを指しています。

    -コードの意味
	    •unset($_SESSION['board_token']);:
	        •これは、セッションに保存されていた board_token というデータを削除します。
	        •	このトークンは、ユーザーがフォームを送信する際に、正しいユーザーであることを確認するために使われます。トークンを使い終わったら、セキュリティのために削除します。
	    •unset($_POST['board_token']);:
	        •これは、フォームから送信された board_token というデータを削除します。
	    •同じく、トークンが送信された後はもう必要ないので、フォームのデータからも削除しています。

    -なぜこの処理が必要なのか？
	    •セキュリティのため:
	    •トークン（board_token）は、一度使われたらそのまま残しておくと、他の人が同じトークンを使って不正な操作を行う可能性があります。
	    •そのため、使い終わったトークンはすぐに削除して、次に使われないようにしています。


<isLoggedIn() メソッド>
public function isLoggedIn()
{
    return isset($_SESSION['user_id']);
}

#メソッドの概要
このPHPコードは、isLoggedInという関数を定義しています。この関数は、ユーザーがログインしているかどうかを確認するために使われます。

#処理内容
return isset($_SESSION['user_id']);
    •isset()：これはPHPの組み込み関数で、括弧内の変数や配列の要素が存在しているかどうかを確認します。存在していればtrueを返し、存在していなければfalseを返します。
	•$_SESSION['user_id']：$_SESSIONはPHPのスーパーグローバル変数で、セッションに保存されているデータにアクセスするために使います。['user_id']は、そのセッションの中のuser_idという名前のデータを指します。

#この関数の意味
このisLoggedIn関数は、ユーザーがログインしているかどうかを確認します。具体的には、セッションにuser_idという名前のデータが保存されているかどうかを調べます。
	•user_idがセッションに存在している場合（つまり、ユーザーがログインしている場合）、isset($_SESSION['user_id'])はtrueを返し、関数全体もtrueを返します。
	•user_idがセッションに存在しない場合（つまり、ユーザーがログインしていない場合）、isset($_SESSION['user_id'])はfalseを返し、関数全体もfalseを返します。



<DeleteSuccess.php フローチャート>
開始
    |
    v
[SessionManagerインスタンス作成]
    |
    v
[セッション開始 (startSession())]
    |
    v
[掲示板ページへのリダイレクト (3秒後)]
    |
    v
終了

<UpdateEdit.php フローチャート>
[開始]
    |
    v
[セッション開始 (startSession())]
    |
    v
[POSTリクエストの処理 (handleRequest())]
    |
    +-------------------------------+
    |                               |
    v                               v
[更新ボタンが押されたか確認]   [キャンセルボタンが押されたか確認]
    |                               |
    |                               v
    |                     [更新処理をキャンセル (cancelUpdate())]
    |                               |
    v                               |
[投稿情報取得 (getPostInfo())]       |
    |                               |
    v                               |
[投稿情報をセッションに保存]          |
    |                               |
    v                               |
[更新処理 (updatePost())]            |
    |                               |
    +--> [トークンの検証 (validateToken())]
    |                               |
    +--> [入力の検証 (validateInputs())]
    |                               |
    +--> [エラーがないか確認 (isValid())]
    |                               |
    +--> [投稿内容を更新 (executeUpdate())]
    |                               |
    v                               |
[掲示板ページにリダイレクト (board.php)] <------------------+
    |
    v
[終了]











<User.php>
[Userクラスのインスタンス作成]
    |
    v
[Databaseクラスのインスタンス生成]
    |
    v
[SessionManagerクラスのインスタンス生成]
    |
    v
[セッションを開始 (startSession())]
    |
    v
[リクエストに基づいて処理を選択]
    |
    +---------------------------+
    |                           |
    v                           v
[ログイン処理 (login())]       [ログアウト処理 (logout())]
    |                           |
    v                           v
[ユーザー名でDBから情報取得]    [セッションを破棄してログアウト]
    |                           |
    v                           v
[パスワードが一致するか確認]   [リダイレクトなどの処理]
    |                           |
    +---------> [一致]          |
    |             |             |
    |             v             |
    |     [セッションにuser_id保存]
    |             |
    |             v
    +-> [ログイン成功 -> trueを返す]
    |
    +-> [ログイン失敗 -> falseを返す]

    |
    v
[新規ユーザー登録 (register())]
    |
    v
[パスワードをハッシュ化]
    |
    v
[ユーザー名とハッシュ化パスワードをDBに保存]