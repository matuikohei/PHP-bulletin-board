<スーパーグローバル関数とは>
スーパーグローバル変数は、PHPのどこからでもアクセスできる特別な変数のこと。これらの変数は、特定の種類のデータを格納するために使われる。
スーパーグローバル変数は、PHPが自動的に提供する特別な配列（配列と連想配列がある）で、自分がコードを作成して配列を準備する必要はない。

主なスーパーグローバル変数
$_POST：フォームから送信されたデータを格納。
$_GET：URLパラメータから送信されたデータを格納。
$_SESSION：セッションデータを格納。
$_COOKIE：クッキーのデータを格納。
$_REQUEST：$_GET、$_POST、および$_COOKIEのデータを格納。
$_SERVER：サーバー環境に関する情報を格納。
$_FILES：ファイルのアップロードに関する情報を格納。
$_ENV：環境変数を格納。
$_GLOBALS：全てのグローバル変数を格納。



<$_POSTについて>
・$_POST：フォームのデータが入る箱
・‘post_btn’：ボタンの名前
・$_POST[‘post_btn’]：そのボタンが押されたという情報が格納される場所。



＜セッションとクッキーの違い iPhoneに例えると＞
セッション: サーバー側に保存され、ユーザーがウェブサイトを訪れている間だけ有効。ログイン状態など一時的なデータを管理するのに使われる。
クッキー: ブラウザに保存され、長期間にわたってデータを保持します。ユーザーの設定や訪問履歴などを保存するのに使われる。

iPhone
セッション: これは、アプリを開いている間にアプリ(WEBサイト)がサーバーに保存している情報。アプリを閉じたり、iPhoneを再起動したりすると、セッションは終了する。
クッキー: これは、iPhone自体に保存される設定情報。例えば、ブラウザのクッキーは、あなたがサイトを訪れるたびにその設定やログイン状態を記憶してくれる。iPhoneを再起動しても、クッキーは残っていて、次回サイトに訪れたときに再びログインした状態を維持する。



<掲示板サイトのセッションについて>
if (isset($_SESSION['cont_id'])) {
$cont_id = $_SESSION['cont_id'];
} else {
$_SESSION['cont_id'] =
chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) .
chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) .
chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) .
chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) .
chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) .
chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) . chr(mt_rand(65, 90)) .
chr(mt_rand(65, 90)) . chr(mt_rand(65, 90));
$cont_id = $_SESSION['cont_id'];
}
このコードでは、ユーザーごとの識別idをセッションに格納している



<isset関数を使う理由>
if (isset($_POST['post_btn'])) {
    // ボタンが押されたときの処理
}

ボタンが押されたを確認するため（エラーを起こさずに確認するため）
issetは変数が定義されているか確認するための関数。
フォームが送信されると、送信されたデータは $_POST 配列に格納される。もしボタンが押されていなければ、$_POST['post_btn'] は存在しない。isset を使うことで、ボタンが押されたかどうかを確認できる。
つまり、isset関数を使う理由は、ボタンが押されたかどうかを安全に確認するため。
もし isset を使わずに $_POST['post_btn'] にアクセスしようとすると、ボタンが押されていない場合にエラーが発生する可能性がある。具体的には下記のようなコードではエラーが起きる可能性がある。
if ($_POST['post_btn']) {
}

$_POST['post_btn'] が存在するかどうかを確認することで、ボタンが押された時にだけ処理を行うことでできる。これによりエラーを避けることできる。



<unset関数について　使う理由>
unset() を記述しない場合、古いデータや不要なデータがセッションに残り、次回フォームを表示したときに誤った情報が表示される可能性がある。
そのため最新の情報だけをセッションに保存し、フォームが正確に表示されるようにするためにunset関数を使用している



<if文がネストせずに連続する理由>
各 if 文の条件が独立しているから。それぞれの条件が順番にチェックされ、対応する処理が実行される。ネストを使う必要がないのは、各条件が他の条件に依存していないため。

・もし条件が独立しているとはどういうことか？
例

	1.	歯を磨く
	•	「もし起きたら、歯を磨く」
	2.	顔を洗う
	•	「もし起きたら、顔を洗う」
	3.	朝ごはんを食べる
	•	「もし起きたら、朝ごはんを食べる」

この3つの「もし〜したら」の条件は、それぞれ別々のことをしている。歯を磨くかどうかは、顔を洗うかどうかに関係ない。同じように、朝ごはんを食べるかどうかも、他の2つには関係ない。

だから、これらは独立していると言える。起きた時に、順番にこれらのことを確認して、それぞれをやるかどうかを決めます。


・もし条件が連続しているとはどういうことか？

例

	1.	もし、雨が降っているなら
	•	傘を持つ
	•	もし、傘を持っているなら
	•	雨具を着る

この場合、「雨が降っているなら、傘を持つ」という条件がまずあり、その後で「傘を持っているなら、雨具を着る」という条件が続いている。

このように、一つの条件が成立した場合、その次の条件がさらにチェックされるのが連続している条件。



<＄SESSIOのtitleやcommentの中にデータを入れてきたのに、最終的に変数、$title や $comment にデーターを入れた理由>
PHPコードの中で、セッション変数から一時的なローカル変数にデータを移す理由は、処理の分かりやすさや効率性、セキュリティなどの複数の要因がある。
セッション変数はユーザーの入力データを保持するために使い、ローカル変数は特定の処理（ここではデータベースへの保存）を効率的に行うために使われる。

セッション変数とローカル変数の役割
1. セッション変数の役割

	•	セッション変数 ($_SESSION['title'] や $_SESSION['comment']) は、ユーザーがページを移動してもデータを保持するために使わる。
	•	ユーザーがフォームに入力したデータを保持し、エラーメッセージが表示された場合でも入力内容を再表示するために使われる。

2. ローカル変数の役割

	•	ローカル変数 ($title や $comment) は、データベースに保存する際や、一時的にデータを処理するために使われる。
	•	データベース操作や他の処理では、セッション変数を直接操作するよりも、ローカル変数を使った方がコードがシンプルで分かりやすくなる。



<PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC, // データをカラム名をキーとする連想配列で取得する　の意味>
このコードは、データベースから取り出したデータを「連想配列」として取得するための設定。
「カラム名をキーとする」とは、データベースから取得したデータを連想配列として扱う際に、データベースのカラム名（列の名前）を配列のキー（識別子）として使うことを意味する。以下に具体例。
$users = [
    [
        'id' => 1,
        'name' => '太郎',
        'age' => 10
    ],
    [
        'id' => 2,
        'name' => '花子',
        'age' => 12
    ]
];


<$post_list = $stmt->fetchAll(PDO::FETCH_ASSOC); // 投稿情報を辞書形式ですべて取得の意味>


<基本構文>
try {
    // エラーが発生するかもしれないコード
} catch (Exception $e) {
    // エラーが発生した場合の処理
}

1.	PDOクラスのインスタンス作成:
$pdo = new PDO('dsn', 'username', 'password', options);
•dsn: データソース名。データベースの種類、ホスト名、データベース名などを含む。
•username: データベースユーザー名。
•password: データベースパスワード。
•options: 配列形式で接続オプションを指定（省略可能）。

2.	例外処理設定:
PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION

3.	プリペアドステートメント設定:
PDO::ATTR_EMULATE_PREPARES => false



<フローチャート>

[開始]
    |
[フォーム送信確認] -> [CSRFトークン確認] -> [トークン無効なら終了]
    |                       |
    v                       v
[トークン破棄] -> [セッションID破棄]
    |
    v
[タイトル確認] -> [セッション変数titleに保存]
    |               |
    v               v
[コメント確認] -> [セッション変数commentに保存]
    |               |
    v               v
[タイトルエラーメッセージ] -> [コメントエラーメッセージ]
    |
    v
[投稿処理確認]
    |
    v
[投稿処理]
    |
[終了]